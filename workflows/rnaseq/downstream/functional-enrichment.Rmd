# Functional enrichment analysis

Here we perform gene ontology, KEGG pathway and Reactome pathway enrichment using the
[clusterProfiler](https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html)
package with some custom plotting functions.

```{r cprof_setup, results='hide'}

# output directory for clusterProfiler results
cprof.folder <- "clusterprofiler"
plots.folder <- "clusterprofiler/plots"

# check for subfolder and create if absent
ifelse(!dir.exists(file.path('.',cprof.folder)),
       dir.create(file.path('.',cprof.folder), recursive = TRUE), NA)
ifelse(!dir.exists(file.path('.',plots.folder)),
       dir.create(file.path('.',plots.folder), recursive = TRUE), NA)

# NOTE: keyTypes to obtain from bitr-------------------------------------------
types <- c("ENTREZID","SYMBOL","UNIPROT")

# NOTE: convert IDs to symbols for KEGG?---------------------------------------
id.convert <- TRUE
```

```{r bitr_genes, results='hide'}
# NOTE: Gene IDs are provided in what format?----------------------------------
from.type <- "FLYBASE"

deg.list <- nested.lapply(sel.list, rownames)
genes.df <- nested.lapply(deg.list, bitr, fromType=from.type, toType=types, OrgDb=orgdb)

```

```{r}
# This function performs GO/pathway enrichment

# GO enrichment
enrichGO.fun <- function(ont,
                         gene,
                         keytype,
                         universe,
                         pvalueCutoff,
                         qvalueCutoff,
                         orgdb,

                         annotation_genus_species=NULL,
                         annotation_key_override=NULL,
                         cache=NULL){
    # NOTE: orgdb is specified for non-parallel operation

    if(missing(orgdb)){
        # this is necessary since a new connection to the database
        # is needed within the scope of the function passed to bplapply
        # for the parallelization to work, so here we recreate a minimal
        # version of get.orgdb

        # NOTE: Instead of querying the database again to find species
        # name, the original get.orgdb function, can also return the
        # species name being used
        proxy <- Sys.getenv('http_proxy')
        if(proxy == "") proxy <- NULL
        ah <- AnnotationHub::AnnotationHub(
                hub=AnnotationHub::getAnnotationHubOption('URL'),
                cache=cache,
                proxy=proxy,
                localHub=FALSE)
        ah.query <- AnnotationHub::query(ah, 'OrgDb')
        idx <- grep(paste0('^', annotation_genus_species, '$'),
                    ah.query$species)
        orgdb <- ah[[names(ah.query)[idx]]]
    }

    res <- clusterProfiler::enrichGO(gene=gene,
                    universe=universe,
                    keyType=keytype,
                    OrgDb=orgdb,
                    ont=ont,
                    pvalueCutoff=pvalueCutoff,
                    qvalueCutoff=qvalueCutoff,
                    readable=TRUE)
    res
}

# KEGG or Reactome functions
enrichPathway.fun <- function(gene,
                              pathway,
                              organism,
                              keytype,
                              universe,
                              pvalueCutoff,
                              qvalueCutoff){

    if(pathway == 'KEGG'){
        res <- clusterProfiler::enrichKEGG(
                        gene=gene,
                        universe=universe,
                        keyType=keytype,
                        organism=organism,
                        pvalueCutoff=pvalueCutoff,
                        qvalueCutoff=qvalueCutoff)
    } else if(pathway == 'Reactome'){
        res <- ReactomePA::enrichPathway(
                        gene=gene,
                        universe=universe,
                        organism=organism,
                        pvalueCutoff=pvalueCutoff,
                        qvalueCutoff=qvalueCutoff,
                        readable=TRUE)
    }
    res
}
```

```{r enrich_all, results='hide', cache=TRUE, dependson=c('parallel','final_clusters')}

# creating longer list to test effect of parallelizing
ngenes <- 150
g1 <- list(up=sample(rownames(res.list[[1]][['res']]), ngenes),
           dn=sample(rownames(res.list[[1]][['res']]), ngenes))
deg.list <- list(a=g1, b=g1,
                 c=g1, d=g1,
                 e=g1, f=g1,
                 g=g1, h=g1,
                 i=g1, j=g1)
genes.df <- nested.lapply(deg.list, bitr, fromType=from.type, toType=types, OrgDb=orgdb)

time.list <- list()

# run enrichment for all gene lists over a loop

# NOTE: settings for clusterProfiler and plots---------------------------------
go.keytype <- 'ENTREZID'
kegg.keytype <- 'ncbi-geneid'
pvalueCutoff <- 1
qvalueCutoff <- 1
go.uni <- NULL
path.uni <- NULL
kegg.organism <- 'dme'
RUN.REACTOME <- FALSE
reactome.organism <- 'fly'


# list to hold all enrichment results
# will have structure:
#
#   all.enrich[[contrast]][[direction]][[enrichment label]]
all.enrich <- list()
enrich.files <- list()

# loop over selection list
for(sel in sel.names){

    start_time <- proc.time()
    gene <- lapply(genes.df, pluck, sel, go.keytype)

    # list to hold results from GO enrichment
    go.res <- list()
    for (ont in c('CC', 'BP', 'MF')){
        if(!parallel){
            go.res[[ont]] <- lapply(gene, enrichGO.fun,
                                    ont=ont,
                                    keytype=go.keytype,
                                    universe=go.uni,
                                    orgdb=orgdb,
                                    pvalueCutoff=pvalueCutoff,
                                    qvalueCutoff=qvalueCutoff)
        } else {
            go.res[[ont]] <- bplapply(gene, enrichGO.fun,
                                      ont=ont,
                                      keytype=go.keytype,
                                      universe=go.uni,
                                      pvalueCutoff=pvalueCutoff,
                                      qvalueCutoff=qvalueCutoff,

                                      # some extra params for orgdb
                                      annotation_genus_species=annotation_genus_species,
                                      cache=new.cache,
                                      annotation_key_override=annotation_key_override,

                                      BPPARAM=SnowParam(nworkers,
                                                        stop.on.error=FALSE))
        }
    }

    # perform KEGG enrichment
    pathway.res <- list()
    if(!parallel){
        pathway.res[['KEGG']] <- lapply(gene, enrichPathway.fun,
                                        pathway='KEGG',
                                        universe=path.uni,
                                        organism=kegg.organism,
                                        keytype=kegg.keytype,
                                        pvalueCutoff=pvalueCutoff,
                                        qvalueCutoff=qvalueCutoff)
    } else {
        pathway.res[['KEGG']] <- bplapply(gene, enrichPathway.fun,
                                          pathway='KEGG',
                                          universe=path.uni,
                                          organism=kegg.organism,
                                          keytype=kegg.keytype,
                                          pvalueCutoff=pvalueCutoff,
                                          qvalueCutoff=qvalueCutoff,
                                          BPPARAM=SnowParam(nworkers,
                                                            stop.on.error=FALSE))
    }

    if (RUN.REACTOME) {
        # NOTE: Install OrgDb--------------------------------------------------
        #   ReactomePA requires the relevant OrgDb package to be installed
        #   and so is disabled by default.
        if(!parallel){
            pathway.res[['Reactome']] <- lapply(gene, enrichPathway.fun,
                                                pathway='Reactome',
                                                universe=path.uni,
                                                organism=reactome.organism,
                                                pvalueCutoff=pvalueCutoff,
                                                qvalueCutoff=qvalueCutoff,
                                                readable=TRUE)
        } else {
            pathway.res[['Reactome']] <- bplapply(gene, enrichPathway.fun,
                                                  pathway='Reactome',
                                                  universe=path.uni,
                                                  organism=reactome.organism,
                                                  pvalueCutoff=pvalueCutoff,
                                                  qvalueCutoff=qvalueCutoff,
                                                  readable=TRUE,
                                                  BPPARAM=SnowParam(nworkers,
                                                                    stop.on.error=FALSE))
        }

    }
    end_time <- proc.time()
    time.list[[sel]] <- end_time - start_time

    # read the enrichment objects into the all.enrich list structure
    for(comp in names(genes.df)){
        if(!comp %in% names(all.enrich)) all.enrich[[comp]] <- list()
        if(!sel %in% names(all.enrich[[comp]])) all.enrich[[comp]][[sel]] <- list()
        for(ont in c('CC', 'BP', 'MF')){
            all.enrich[[comp]][[sel]][[ont]] <- go.res[[ont]][[comp]]
        }

        for(pathway in c('KEGG','Reactome')){
            res <- pathway.res[[pathway]][[comp]]

            # NOTE: here we convert the ENTREZID to symbols for KEGG
            # enrichment results. Chunk to be replaced with helper function
            if(pathway == 'KEGG' && !is.null(res)){
                if(id.convert){
                  id.vec <- genes.df[[comp]][[sel]]$SYMBOL
                  names(id.vec) <- genes.df[[comp]][[sel]]$ENTREZID
                  res.genes <- res@result$geneID
                  for(j in 1:length(res.genes)){
                    id.split <- strsplit(res.genes[j], "/")[[1]]
                    temp <- paste(id.vec[id.split], collapse="/")
                    res@result$geneID[j] <- temp
                  }
                }  
            }
            all.enrich[[comp]][[sel]][[pathway]] <- res
        }
    }
}

```

```{r results='asis'}
mdcat('Time taken for ', ifelse(parallel, 'parallel', 'non-parallel'), ' run: ')

for(sel in names(time.list)){
    cat(' - ', sel, ': ', time.list[[sel]][[3]], ' s\n')       
}
mdcat('\n')
```

```{r output_go, cache=TRUE, dependson='enrich_all'}
enrich.files <- list()
for(comp in names(genes.df)){
    enrich.files[[comp]] <- list()
    for(sel in sel.names){
        enrich.files[[comp]][[sel]] <- list()
        pathways <- c('BP','CC','MF','KEGG')
        if(RUN.REACTOME) pathways <- c(pathways, 'Reactome')
        for(p in pathways){
            res <- all.enrich[[comp]][[sel]][[p]]
            if(!is.null(res))
              enrich.files[[comp]][[sel]][[p]] <- write.clusterprofiler.results(res,
                                                                cprof.folder,
                                                                paste(p, comp, sel, sep='_'))
        }
    }
}
```

```{r adjust_catlen, cache=TRUE, dependson='enrich_all'}

# This shortens the names of functional terms for better visualization
maxcatlen <- 50
for(comp in names(all.enrich)){
  for(name in names(all.enrich[[comp]])){
    for(go in names(all.enrich[[comp]][[name]])){
      all.enrich[[comp]][[name]][[go]]@result$Description <- substr(all.enrich[[comp]][[name]][[go]]@result$Description, 1, maxcatlen)
    }
  }
}

```

Below we show the results separately for each comparison. Links to files
containing analysis results are shown above each set of plots, with parsed
files showing genes on separate lines.

```{r plot_go, fig.width=15, fig.height=10, results='asis', cache=TRUE, dependson='enrich_all'}
# go labels for file names
go.label <- list(
    BP='GO Biological Process',
    CC='GO Cellular Component',
    MF='GO Molecular Function',
    kegg='KEGG Pathways',
    reactome='Reactome Pathways')

comp.label <- lapply(res.list, function (x) x[['label']])

for(comp in names(all.enrich)){
    mdcat('## ', comp.label[[comp]], ' {.tabset}')
    for(go in names(go.label)){

        mdcat('### ', go.label[[go]], ' {.tabset}')

        mdcat('TSV format results (condensed and split versions):\n')

        dotplots <- list()
        emapplots <- list()
        cnetplots <- list()

        for (sel in sel.names){

            res <- all.enrich[[comp]][[sel]][[go]]

            if (is.null(res))
            {
                cat('\n\n\nNo genes enriched for:', comp, sel, go, '\n\n\n')
                next
            }

            outfiles <- enrich.files[[comp]][[sel]][[go]]
            f1 <- outfiles[['orig']]
            f2 <- outfiles[['split']]
            mdcat(' - ', sel, ' [', f1, '](', f1 ,')', ', [', f2, '](', f2 ,')')
            title <- paste(sel, go)

            # NOTE: arguments to dotplot, emapplot, and cnetplot---------------
            #   Arguments provided are package defaults, explicitly provided
            #   here for better visibility on what to tweak. Most commonly
            #   adjusted is probably the showCategory argument.

            dotplots[[sel]] <- dotplot(
                res,
                showCategory=10,
                color='p.adjust',
                x='GeneRatio'
            ) +
                ggtitle(title) +
                theme(plot.title=element_text(hjust=0.5, size=15, face='bold'))

            # If there is only one gene, then we don't have a directed graph --
            # "Error in graph_to_tree(graph, mode = direction) : Graph must be directed"
            if (nrow(res@result) > 1){
                emapplots[[sel]] <- emapplot(
                    res,
                    showCategory=30,
                    color='p.adjust'
                ) +
                    ggtitle(title) +
                    theme(plot.title=element_text(hjust=0.5, size=15, face='bold'))
            }

            cnetplots[[sel]] <- cnetplot(
                res,
                showCategory=5,
                foldChange=NULL,
                colorEdge=FALSE,
                circular=FALSE,
                node_label="all"
            ) +
                ggtitle(title) +
                theme(plot.title=element_text(hjust=0.5, size=15, face='bold'))
        }

        save.and.link <- function(plottype){
            f <- file.path(plots.folder, paste0(go,"_", comp,"_", plottype, ".pdf"))
            dev.copy(pdf, file=f, width=15, height=10)
            dev.off()
            mdcat('Link to pdf - [', f, '](', f, ')')
            cat('\n')
        }

        # It's possible that we got this far without any results to plot; if so
        # then skip creating the tabs and plots
        skip <- (length(dotplots) == 0) & (length(emapplots) == 0) & (length(cnetplots) == 0)

        if (length(dotplots) > 0){
            mdcat('#### Dotplot')
            print(plot_grid(plotlist=dotplots, align='hv'))
            save.and.link('dotplot')
        }
        if (length(emapplots) > 0){
            mdcat('#### Emapplot')
            print(plot_grid(plotlist=emapplots, align='hv'))
            save.and.link('emapplot')
        }
        if (length(cnetplots) > 0){
            mdcat('#### Cnetplot')
            print(plot_grid(plotlist=cnetplots, align='hv'))
            save.and.link('cnetplot')
        }
    }
}
```
