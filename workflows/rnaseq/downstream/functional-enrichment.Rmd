# Functional enrichment analysis

Here we perform gene ontology, KEGG pathway and Reactome pathway enrichment using the
[clusterProfiler](https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html)
package with some custom plotting functions.

```{r cprofsetup, results='hide'}
# Initial setup for clusterProfiler chunks below.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#cprofsetup

# output directory for clusterProfiler results
cprof.folder <- "clusterprofiler"
plots.folder <- "clusterprofiler/plots"

# check for subfolder and create if absent
ifelse(!dir.exists(file.path('.',cprof.folder)),
       dir.create(file.path('.',cprof.folder), recursive = TRUE), NA)
ifelse(!dir.exists(file.path('.',plots.folder)),
       dir.create(file.path('.',plots.folder), recursive = TRUE), NA)

# NOTE: keyTypes to obtain from bitr-------------------------------------------
types <- c("ENTREZID", "SYMBOL", "UNIPROT")

# NOTE: convert IDs to symbols for KEGG?---------------------------------------
id.convert <- TRUE
```

```{r bitrgenes, results='hide'}
# Convert gene IDs to those useable to clusterProfiler.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#bitrgenes
# NOTE: Gene IDs are provided in what format?----------------------------------
from.type <- 'ENSEMBL'
annotation_genus_species <- 'Mus musculus'
annotation_key_override <- NA
hub.cache <- '../../../include/AnnotationHubCache'
orgdb <- get.orgdb(
    annotation_genus_species,
    cache=hub.cache,
    annotation_key_override=annotation_key_override
)
# In place of AnnotationDbi::select, Use a wrapper function to run this command in order to catch the unmatching keys error
# The func parameter corresponds to AnnotationDbi::select
# The pattern parameter is used to identify the error raised when you have genes, but these genes do not encode proteins
# This may happen as functional enrichment is only defined for proteins as of now. 
# This is the common form of the error message: "Error in .testForValidKeys(x, keys, keytype, fks) : 
#"None of the keys entered are valid keys for 'ENSEMBL'. Please use the keys method to see a listing of valid arguments."
# You do not need to pass this entire thing to the wrapper, just enough that it can be identified with a grep search. 
# When the exception is caught, assign the contrast a null value and interpret that value downstream in the Rmd.
keyhandler <- function(func, pattern,  ...) {

    wrapped_select <- function(...) {
        tryCatch(
            {
             func(...)
            },
            error = function(e){
                msg <- conditionMessage(e)
                if (grepl(pattern, msg)){
                    message("Caught a valid key exception in AnnotationDbi::select. Confirm that, for contrasts with no functional enrichment, the genes do not encode proteins")

                    return(NULL)
                    } else {
                    stop(msg)
                }
            }
        )
    }
    wrapped_select
}
select.keyhandler <- keyhandler(AnnotationDbi::select, 'None of the keys')

deg.list <- nested.lapply(sel.list, rownames)
genes.df <- nested.lapply(deg.list, function (x) select.keyhandler(orgdb, keys=x, columns=types, keytype=from.type))


```

```{r enrichall, results='hide', cache=TRUE, dependson='selections'}
# Perform enrichment analyses.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#enrichall

# run enrichment for all gene lists over a loop

# NOTE: settings for clusterProfiler and plots---------------------------------
go.keytype <- 'ENTREZID'
kegg.keytype <- 'ncbi-geneid'
pvalueCutoff <- 1
qvalueCutoff <- 1
go.uni <- NULL
path.uni <- NULL
kegg.organism <- 'mmu'
RUN.REACTOME <- FALSE
reactome.organism <- 'mouse'
min.gene.set.size <- 50

# Make a list to report which contrasts caught expections 

except.list <- list()

# list to hold all enrichment results
# will have structure:
#
#   all.enrich[[contrast]][[direction]][[enrichment label]]
all.enrich <- list()
enrich.files <- list()
# loop over each contrast
for(comp in names(genes.df)){

    all.enrich[[comp]] <- list()
    enrich.files[[comp]] <- list()

    # loop over selection list
    for(sel in sel.names){
        all.enrich[[comp]][[sel]] <- list()
        enrich.files[[comp]][[sel]] <- list()

        #Checking for nullity (coerced by above if the exception was caught)
        if (is.null(genes.df[[comp]][[sel]])) {
            #record the contrasts that caused an error
            except.list <- append(except.list, paste(comp,sel, sep = " "))
            next
        }
        gene <- genes.df[[comp]][[sel]][[go.keytype]]

        if (sum(!is.na(gene)) < min.gene.set.size){
            next
        }

        for (ont in c('CC', 'BP', 'MF')){
            go.res <- enrichGO(
                gene=gene, universe=go.uni, keyType=go.keytype, OrgDb=orgdb,
                ont=ont, pvalueCutoff=pvalueCutoff, qvalueCutoff=qvalueCutoff,
                readable = TRUE)

            res.label <- paste('GO', ont, sep='_')
            all.enrich[[comp]][[sel]][[ont]] <- go.res
            if (!is.null(go.res)){
                enrich.files[[comp]][[sel]][[ont]] <- write.clusterprofiler.results(go.res, cprof.folder, paste0(res.label, '_', comp, '_', sel))
            }
        }

        # perform KEGG enrichment
        res.label <- 'KEGG'
        kegg.res <- enrichKEGG(
            gene=gene, universe=path.uni, organism=kegg.organism,
            keyType=kegg.keytype, pvalueCutoff=pvalueCutoff,
            qvalueCutoff=qvalueCutoff)


        if (!is.null(kegg.res)){
            # convert uniprot IDs to readable symbols. This needs to be done separately
            # in the case of KEGG
            if(id.convert){
              id.vec <- genes.df[[comp]][[sel]]$SYMBOL
              names(id.vec) <- genes.df[[comp]][[sel]]$ENTREZID
              kegg.res.genes <- kegg.res@result$geneID
              for(j in 1:length(kegg.res.genes)){
                id.split <- strsplit(kegg.res.genes[j], "/")[[1]]
                temp <- paste(id.vec[id.split], collapse="/")
                kegg.res@result$geneID[j] <- temp
              }
            }

            all.enrich[[comp]][[sel]][['kegg']] <- kegg.res
            enrich.files[[comp]][[sel]][['kegg']] <- write.clusterprofiler.results(kegg.res, cprof.folder, paste0(res.label, '_', comp, '_', sel))
        }

        if (RUN.REACTOME) {
            # NOTE: Install OrgDb--------------------------------------------------
            #   ReactomePA requires the relevant OrgDb package to be installed
            #   and so is disabled by default.
            res.label <- 'Reactome'
            reactome.res <-enrichPathway(
                gene=gene, universe=path.uni, organism=reactome.organism,
                pvalueCutoff=pvalueCutoff, qvalueCutoff=qvalueCutoff, readable=TRUE)
            all.enrich[[comp]][[sel]][['reactome']] <- reactome.res

            if (!is.null(reactome.res)){
                enrich.files[[comp]][[sel]][['reactome']] <- write.clusterprofiler.results(reactome.res, cprof.folder, paste0(res.label, '_', comp, '_', sel))
            }
        }
    }
}

```

```{r adjustcatlen}
# Tweak the annotation names.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#adjustcatlen

# This shortens the names of functional terms for better visualization
maxcatlen <- 50
for(comp in names(all.enrich)){
  for(name in names(all.enrich[[comp]])){
    for(go in names(all.enrich[[comp]][[name]])){
      all.enrich[[comp]][[name]][[go]]@result$Description <- substr(all.enrich[[comp]][[name]][[go]]@result$Description, 1, maxcatlen)
    }
  }
}

```

Below we show the results separately for each comparison. Links to files
containing analysis results are shown above each set of plots, with parsed
files showing genes on separate lines.

```{r plotgo, fig.width=15, fig.height=10, results='asis', cache=TRUE, dependson='enrich_all'}
# Plot the enrichment results.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#plotgo

# go labels for file names
go.label <- list(
    BP='GO Biological Process',
    CC='GO Cellular Component',
    MF='GO Molecular Function',
    kegg='KEGG Pathways',
    reactome='Reactome Pathways')

comp.label <- lapply(res.list, function (x) x[['label']])

for(comp in names(all.enrich)){
    mdcat('## ', comp.label[[comp]], ' {.tabset}')
    for(go in names(go.label)){

        mdcat('### ', go.label[[go]], ' {.tabset}')

        mdcat('TSV format results (condensed and split versions):\n')

        dotplots <- list()
        emapplots <- list()
        cnetplots <- list()

        for (sel in sel.names){

            if (paste(comp, sel, sep=" ") %in% except.list) {
                cat('\n\n\nNo protein-encoding genes for:', comp, sel, '\n\n\n')
                next
            }
            res <- all.enrich[[comp]][[sel]][[go]]

            if (is.null(res))
            {
                cat('\n\n\nNo genes enriched for:', comp, sel, go, '\n\n\n')
                next
            }
            outfiles <- enrich.files[[comp]][[sel]][[go]]
            f1 <- outfiles[['orig']]
            f2 <- outfiles[['split']]
            mdcat(' - ', sel, ' [', f1, '](', f1 ,')', ', [', f2, '](', f2 ,')')
            title <- paste(sel, go)

            # NOTE: arguments to dotplot, emapplot, and cnetplot---------------
            #   Arguments provided are package defaults, explicitly provided
            #   here for better visibility on what to tweak. Most commonly
            #   adjusted is probably the showCategory argument.

            dotplots[[sel]] <- dotplot(
                res,
                showCategory=10,
                color='p.adjust',
                x='GeneRatio'
            ) +
                ggtitle(title) +
                theme(plot.title=element_text(hjust=0.5, size=15, face='bold'))

            # If there is only one gene, then we don't have a directed graph --
            # "Error in graph_to_tree(graph, mode = direction) : Graph must be directed"
            if (nrow(res@result) > 1){
                try(
                emapplots[[sel]] <- emapplot(
                    res,
                    showCategory=30,
                    color='p.adjust'
                ) +
                    ggtitle(title) +
                    theme(plot.title=element_text(hjust=0.5, size=15, face='bold'))
                )
            }

            cnetplots[[sel]] <- cnetplot(
                res,
                showCategory=5,
                foldChange=NULL,
                colorEdge=FALSE,
                circular=FALSE,
                node_label="all"
            ) +
                ggtitle(title) +
                theme(plot.title=element_text(hjust=0.5, size=15, face='bold'))
        }

        save.and.link <- function(plottype){
            f <- file.path(plots.folder, paste0(go,"_", comp,"_", plottype, ".pdf"))
            dev.copy(pdf, file=f, width=15, height=10)
            dev.off()
            mdcat('Link to pdf - [', f, '](', f, ')')
            cat('\n')
        }

        # It's possible that we got this far without any results to plot; if so
        # then skip creating the tabs and plots
        skip <- (length(dotplots) == 0) & (length(emapplots) == 0) & (length(cnetplots) == 0)

        if (length(dotplots) > 0){
            mdcat('#### Dotplot')
            print(plot_grid(plotlist=dotplots, align='hv'))
            save.and.link('dotplot')
        }
        if (length(emapplots) > 0){
            mdcat('#### Emapplot')
            print(plot_grid(plotlist=emapplots, align='hv'))
            save.and.link('emapplot')
        }
        if (length(cnetplots) > 0){
            mdcat('#### Cnetplot')
            print(plot_grid(plotlist=cnetplots, align='hv'))
            save.and.link('cnetplot')
        }
    }
}
```
