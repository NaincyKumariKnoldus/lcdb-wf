# Gene patterns

We can roughly group genes into expression patterns. This uses the [DEGreport
package](https://www.bioconductor.org/packages/release/bioc/html/DEGreport.html),
which in turn uses the
[ConsensusClusterPlus](https://www.bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html)
algorithm to cluster genes into similar expression patterns. The lists of genes
found in each cluster are reported below the plot.

The default general flow is as follows:

```{r dpsettings}

# NOTE: settings for DEGpatterns-----------------------------------------------
#  These parameters are set up here because we will be providing them to
#  multiple degPatterns calls.

# NOTE:  Max number of genes to include----------------------------------------
#   If more genes are differeentially expressed, they will be downsampled to
#   this many
lim <- 2000


# NOTE: Min number of genes to include----------------------------------------
#   If fewer than this many genes, skip the clustering
lower.lim <- 0

# NOTE:  Correlation coefficient above which to merge clusters-----------------
cutoff <- 0.5

# NOTE: x-axis for degPatterns ------------------------------------------------
#   Should be a column in the colData metadata
time <- "group"

# NOTE: color for degPatterns.------------------------------------------------
#   Use NULL for no color.
col <- NULL

# NOTE: This is set very low for test data. Default is 15.---------------------
#   Minimum cluster size.
minc <- 1

# NOTE: This is a very low value used for getting the degPatterns to run -----
low.minc <- 1
```

- Take the union of all genes that are changed across all contrasts
- If there are more than `r lim` genes, randomly sample `r lim` genes (to keep the computations reasonable)
- Cluster genes by coexpression across contrasts
- If clusters are correlated with a correlation coefficient of `r cutoff` or
  more, they are merged together
- Clusters with fewer than `r minc` genes are not shown.

```{r final_clusters, fig.width=12, results='asis', cache=TRUE, dependson='selections'}
# NOTE: which genes to cluster?------------------------------------------------
#    By default, we get all the changed genes, but you may want only the up or
#    down genes.
ll <- lapply(res.list, function (x) get.sig(x[['res']], 'changed'))

# Filter out results where there were zero genes detected.
ll <- ll[lapply(ll, length) > 0]

# list to hold degpatterns results
dp.list <- list()
for (name in names(ll)){
    dp.list[[name]] <- list()

    genes <- ll[[name]]
    dp.list[[name]][['genes']] <- genes

    # Plotting a large number of genes will take a lot of time to perform the
    # clustering. If there are more than this limit, then we take a random
    # sample.
    if (length(genes) > lim){
        genes <- sample(genes, lim)
    }

    if (length(genes) < lower.lim){
        mdcat('**Too few genes (', length(genes), ') to cluster**')
        next
    }

    # Extract the normalized counts for these genes
    idx <- rownames(rld) %in% genes
    ma <- assay(rld)[idx,]

    colData.i <- colData(res.list[[name]][['dds']])
    colData.i <- colData.i[,!(colnames(colData.i) %in% exclude.for.printing)]


    # Sometimes, if there are limited clusters, degPattern fails. The solution
    # below is to reduce the `minc` to a very low number which allows it to run
    # without error, disable plotting, then manually remove the clusters with
    # low numbers of genes, then use the degPlotCluster function to re-plot
    # them.
    dp.list[[name]][['clusters']] <- degPatterns(
        ma,
        colData.i,
        time=time,
        col=col,

        # NOTE: reduce and merge cutoff----------------------------------------
        #   Reduce will merge clusters that are similar; similarity determined
        #   by cutoff
        reduce=TRUE,

        # NOTE: color----------------------------------------------------------
        #   For more complicated designs, try the `col` argument to color the
        #   plot by another factor.
        # col="another.column",

        # NOTE: see above note
        minc=minc,

        plot=FALSE

        )
}
```

```{r plot_degpatterns, cache=TRUE, fig.width=12, results='asis', dependson='final_clusters'}
# unique list of genes in clusters
uniq.genes <- unique(unlist(lapply(dp.list, function(x) x[['genes']])))

# data frame to hold cluster memberships
# NOTE: here we assume that all genes are present in any 'res' object.
#       - this should be replaced by the geneid -> symbol mapping df
cluster.df <- data.frame(row.names = uniq.genes,
                         genes = uniq.genes,
                         symbol = res.list[[1]][['res']]$symbol[uniq.genes])

mdcat('## Cluster plots {.tabset}')
for(name in names(dp.list)){
    # print nice Markdown header
    mdcat('### ', res.list[[name]][['label']])

    p <- dp.list[[name]][['clusters']]

    n <- p$normalized

    # keep clusters with counts > minc
    n.uniq <- n[,c('genes','cluster')] %>% distinct()
    cluster.counts <- table(n.uniq$cluster)
    clusters.keep <- names(cluster.counts)[cluster.counts > minc]
    n2 <- n[n$cluster %in% clusters.keep,]

    if(nrow(n2) > minc){
    print(degPlotCluster(
        n2,
        time=time,
        min_genes=minc,
        col=col
        )
    )
    } else {
        cat('No clusters to plot!\n')
    }
    mdcat('\n')

    # In the final_clusters directory, this creates files containing lists of
    # the genes in each cluster, and adds a link to the Markdown.
    dir.create('final_clusters')
    pdf.file = file.path('final_clusters', paste0(name, '.pdf'))
    dev.copy(pdf, file=pdf.file)
    dev.off()
    mdcat('- [', pdf.file, '](', pdf.file, '), PDF')

    # add cluster membership column to cluster.df
    n2.uniq <- n2[,c('genes','cluster')] %>% distinct()
    cluster.col <- paste0(name,'.cluster')
    cluster.df[[cluster.col]] <- NA
    cluster.df[n2.uniq$genes, cluster.col] <- n2.uniq$cluster
}

# output file with cluster membership
fn <- file.path('final_clusters','final_clusters.tsv')
write.table(cluster.df, file=fn, quote=FALSE, sep='\t', row.names=FALSE)
mdcat('## Exported file')
mdcat('TSV with cluster membership: [', fn, '](', fn, ')')
```
