---
output:
    html_document:
        code_folding: hide
        toc: true
        toc_float: true
        toc_depth: 3
---

```{r, include=FALSE}
# =============================================================================
# IMPORTANT:
# Before running this, search for the string "NOTE:". This indicates parts of
# the file that need to be changed depending on the experiment.
# =============================================================================
#
# This Rmd file aims to include "the works", with some preliminary exploratory
# visualizations, followed by differential expression using both gene models
# and transcript models and some downstream GO analysis.
#
# Look for the string "NOTE:" to identify places that may need some editing.
# Notably, the only model run by default is `~group`, which will only be
# appropriate for the simplest experiments!

# There are a fair amount of helper functions. They are stored in
# `helpers.Rmd`, and included here as a child document so that all code is
# self-contained in the HTML rendered from this RMarkdown.
#-----------------------------------------------------------------------------
```

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
    warning=FALSE,
    message=FALSE,
    cache.extra_file_dep_1=file.info('../config/sampletable.tsv')$mtime,
    cache.extra_file_dep_2 = file.info('../data/rnaseq_aggregation/featurecounts.txt')$mtime
)
```

# Changelog

**Initial results**

Last run: `r date()`

# RNA-seq results

```{r imports}
library(DESeq2)
library(gridExtra)
library(ggplot2)
library(genefilter)
library(readr)
library(tximport)
library(clusterProfiler)
library(AnnotationHub)
library(BiocParallel)
library(UpSetR)
library(ReactomePA)
library(cowplot)
library(plotly)
library(tibble)
library(dplyr)
library(tidyr)
```


```{r run_helpers, child='helpers.Rmd'}
# When running interactively, run the following to load helper functions.
# When rendering this file, the contents of this code block will be skipped
# since it is a "child" block for which all contents are expected to be in
# the other file.
rmarkdown::render('helpers.Rmd', run_pandoc=FALSE)
```

```{r annotationhub_setup}
# NOTE: Organism---------------------------------------------------------------
#   This is the search term used for looking in the AnnotationHub
annotation_genus_species <- 'Drosophila melanogaster'

# NOTE: If you already know the key, provide it here---------------------------
#   Provide this to override the AnnotationHub accession otherwise discovered
annotation_key_override <- NA

# This should generally not be changed unless you know what you're doing
hub.cache <- '../../../include/AnnotationHubCache'

# To ensure that we do not clobber any local copies of the annotation, we copy
# to tmp. This also should increase performance when running on a cluster -- we
# avoid poor sqlite performance on shared filesystems by copying to local
# scratch space.
if(!exists(hub.cache)){
    # create if cache directory does not exist
    # this avoids the directory creation prompt
    dir.create(hub.cache, showWarnings=FALSE, recursive=TRUE)
    new.cache <- hub.cache
} else {
    ok <- file.copy(hub.cache, tempdir(), recursive=TRUE)
    new.cache <- file.path(tempdir(), 'AnnotationHubCache')
}

orgdb <- get.orgdb(
    annotation_genus_species,
    cache=new.cache,
    annotation_key_override=annotation_key_override
)
```

```{r coldata_setup}
# NOTE: path name to sampletable-----------------------------------------------
#   Path is relative to the directory of this Rmd
sample.table.filename <- '../config/sampletable.tsv'

# NOTE: Strip gene versions?---------------------------------------------------
#   Ensembl annotations often come with ".N" version numbers at the end. If
#   TRUE, later code will strip these off.
strip.dotted.version <- TRUE

# NOTE: Which columns to exclude from printing sampletable---------------------
#   If you have very verbose metadata in your sampletable you can exclude those
#   columns here.
exclude.for.printing <- c('featurecounts.path', 'salmon.path', 'orig_filename', 'orig_filename_R2')

colData <- read.table(sample.table.filename, sep='\t', header=TRUE, stringsAsFactors=FALSE)

# NOTE: Paths to Salmon output----------------------------------------------
#    This is configured in the patterns and targets from the workflow; if
#    you've changed anything there you will need to change it here as well.
colData$salmon.path <- sapply(
    colData$samplename,
    function (x) file.path('..', 'data', 'rnaseq_samples', x, paste0(x, '.salmon'), 'quant.sf')
)

# NOTE: Factor columns------------------------------------------------------
#    These are the columns in the sampletable that should be converted to
#    factors
factor.columns <- c('group')
for (col in factor.columns){
    colData[[col]] <- as.factor(colData[[col]])
}

# NOTE: Relevel the factors----------------------------------------------------
#   For the test data, "control" is the base level for the "group" factor, but
#   you will need to edit as appropriate for your experimenal design.
colData$group <- relevel(colData$group, ref='control')

rownames(colData) <- colData[,1]
```

## Experiment overview

Here is the sample table with metadata used for this analysis:

```{r}
knitr::kable(colData[, colnames(colData)[!colnames(colData) %in% exclude.for.printing]])
```

```{r salmon}
# NOTE: Disable salmon?--------------------------------------------------------
#   If you are not intending on using Salmon, set this chunk to eval=FALSE
#
# Load transcript-level counts
txi <- tximport(colData[, 'salmon.path'], type='salmon', txOut=TRUE)
transcript.tpm <- txi$abundance
colnames(transcript.tpm) <- colData$samplename
```

```{r ddstxi, cache=TRUE, eval=FALSE}
dds.txi <- DESeqDataSetFromTximport(
    txi, colData=colData[, -grepl('path', colnames(colData)), drop=FALSE],

    # NOTE: design to use when importing Salmon data.--------------------------
    design=~group
)

# Normalize transcript counts for heatmaps and PCA. We're using vst rather than
# rlog because the DESeq2 docs say they are largely equivalent, and vst is
# substantially faster.
#
# Since this is for exploratory data analysis, we use blind=TRUE
# to ignore the design.
rld.txi <- varianceStabilizingTransformation(dds.txi, blind=TRUE)
```


```{r dds_initial, cache=TRUE}
# Load gene-level counts
dds <- DESeqDataSetFromCombinedFeatureCounts(
    '../data/rnaseq_aggregation/featurecounts.txt',
    sampletable=colData,
    # NOTE: What design to use?------------------------------------------------
    #   This object will be used for EDA, so it's recommended to use a single
    #   factor that describes the samples. We'll be recreating another dds
    #   later for the actual contrasts of interest.
    design=~group)

# NOTE: collapse technical replicates ----------------------------------------
#   If collapsing technical replicates, do so here
# dds <-collapseReplicates(dds, dds$biorep)

if (strip.dotted.version){
    rownames(dds) <- sapply(strsplit(rownames(dds), '.', fixed=TRUE), function (x) x[1])
}

# Variance-stablilized transform to normalize gene-level counts.
# Alternatively, use `rlog`, but that gives about the same results
# and is slow for large numbers of samples.
#
# Since this is for exploratory data analysis, we use blind=TRUE
# to ignore the design.
rld <- varianceStabilizingTransformation(dds, blind=TRUE)
```

## Sample clustering and QC

The following heatmap shows a hierarchical clustering of pairwise distances
between samples. Darker blue means less distant (i.e. more similar). In general
we expect to see replicates clustering together and separation of treatments.

## Clustered heatmap

```{r, cache=TRUE, dependson='dds_initial'}
# NOTE: Which columns to use for grouping the heatmap?-------------------------
#    Add as many columns as you want for the last argument. The test data uses
#    just the "group" column to create colored boxes corresponding to values of
#    "group" alongside the heatmap.
#
plot.heatmap(rld, colData, c('group'))
```

## PCA {.tabset}

Another way of looking at sample clustering is principal components analysis
(PCA). The x- and y-axes do not have units, rather, they represent the
dimensions along which the samples vary the most. The amount of variance
explained by each principal component is indicated in the axes label.


```{r, results='asis', cache=TRUE, dependson='dds_initial'}
# NOTE: Which columns to use for grouping the heatmap?-------------------------
#    See similiar note above for which columns to group by. Here, each PCA plot
#    will be in a separate tab.
groups <- list(
               group=c('group'),
               layout=c('layout')
               )

# NOTE: Here we make interactive PCA plots using ggplotly. However, this does
#    not work inside a loop. So, if you have multiple groups, copy and paste
#    the following lines, updating the variable 'i'.
p <- list()
for(group in groups){
    p[[group]] <- plotPCA.ly(rld, intgroup=group)
}

i <- 1
mdcat('### ', names(p)[i])
ggplotly(p[[i]])

i <- 2
mdcat('### ', names(p)[i])
ggplotly(p[[i]])

```


## Size factors {.tabset}
Ideally, all libraries were sequenced to identical depth, in which case all
size factors would be 1.0. In practice, this is almost never the case due to
the difficulties of accurately measuring low concentrations of cDNA. These size
factor estimates are DESeq2's way of showing how sequencing depth varies across
libraries. If some libraries are much higher or lower than
1 then those libraries had dramatically different coverage and we should be
careful about interpreting results.

Size factors are calculated according to the median-ratio method (equation 5 of
[Anders & Huber
2010](http://dx.doi.org/10.1186/gb-2010-11-10-r106)).

These diagnostic plots show the size factors (as a ranked bar plot) and the
relationship between the size factors and the total read count (as
a scatterplot).

```{r, results='asis'}
mdcat('### Size factors')
dds <- estimateSizeFactors(dds)
sf <- sizeFactors(dds)
sf <- sf[order(sf)] %>%
        enframe(value = 'Size Factor')

p <- ggplot(sf) +
    aes(x=reorder(name, `Size Factor`), y=`Size Factor`) +
    xlab('sample name') +
    geom_col() +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplotly(p)

mdcat('### Size factors vs total read count')
trc <- colSums(counts(dds)) %>%
        enframe(value = 'Total Read Count')
trc_vs_sf <- full_join(sf, trc, by = 'name')
group_names <- tibble(name=dds$samplename, group=dds$group)
trc_vs_sf <- full_join(trc_vs_sf, group_names, by = 'name')
p <- ggplot(data=trc_vs_sf, aes_string(x="`Total Read Count`", y="`Size Factor`", label='name')) +
    geom_point(size=3) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplotly(p)
```

```{r}
# NOTE: Run DESeq2 on multiple cores.------------------------------------------
#    By default, we do not run in parallel, however this can be very useful in
#    experiments with many samples and complex designs.  To run in parallel,
#    comment out the line below and set cores appropriately. Then, add the
#    argument `parallel=TRUE` whenever you call DESeq()
#    register(MulticoreParam(4))
parallel <- FALSE
```

```{r dds_models, cache=TRUE}
# NOTE: gene rather than transcript counts-------------------------------------
#    By default we use gene counts rather than transcript counts. See code
#    above where the `dds.txi` object is created for how to modify this for
#    transcript counts.
dds <- DESeqDataSetFromCombinedFeatureCounts(
    '../data/rnaseq_aggregation/featurecounts.txt',
    sampletable=colData,
    # NOTE: What design to use?------------------------------------------------
    #   This will be used for contrasts below.
    design=~group)

if (strip.dotted.version){
    rownames(dds) <- sapply(strsplit(rownames(dds), '.', fixed=TRUE), function (x) x[1])
}

# NOTE: collapse technical replicates ----------------------------------------
#  If collapsing technical replicates, do so (again) here
# dds <-collapseReplicates(dds, dds$biorep)

dds <- DESeq(dds,
    # NOTE: betaPrior----------------------------------------------------------
    #    betaPrior=FALSE is the default in DESeq2 >1.16, but here we set it
    #    explicitly for consistency across different versions.
    betaPrior=FALSE,
    parallel=parallel
    )
```


```{r results, cache=TRUE}
# NOTE: lots of editing likely needed in this chunk!---------------------------
#    This chunk builds a data structure like this:
#
#       res.list[[contrast]][[res]]   <- results object for this contrast
#       res.list[[contrast]][[dds]]   <- the dds object for this contrast
#       res.list[[contrast]][[label]] <- a nice label for this contrast
#
#    This is the block that performs the contrasts, filling out the `res.list`
#    named list, which ties together the results, the DESeq object from which the
#    results were extracted, and a descriptive label to be used in plots and
#    headings.
#
#    For each entry in `res.list`, you will get DE results sections automatically
#    created for each item. Each of these sections will have the "label" as its
#    header, and will contain a summary table, MA plots, counts plots of top 3 up-
#    and down-regulated genes, p-value distribution, and exported results tables
#    with links in the rendered HTML to the output files.
#
#    NOTE: Here are some notes on using lfcShrink...
#    As currently implemented (05 apr 2018), lfcShrink checks its arguments for an
#    existing results table. If it exists, it applies shrinkage to the lfc and se
#    in that table. If it *doesn't* exist, it calls results on dds with the syntax
#
#        res <- results(dds, name=coef)
#    or
#
#        res <- results(dds, contrast=contrast)
#
#    It does not pass any further arguments to results, and it doesn't warn you
#    that results-style arguments were unrecognized and ignored. Therefore,
#    lfcShrink DOES NOT directly support lfcThreshold, or other alternative
#    hypotheses, or any of the custom analysis methods you can access through
#    results(). To get those, you have to call results first, without shrinkage,
#    and then apply lfcShrink.
#
#    Here we use the lfcShrink version of the results. In DESeq2 versions >1.16,
#    the lfc shrinkage is performed in a separate step, so that's what we do here.
#    This is slightly different results than if you used betaPrior=TRUE when
#    creating the DESeq object.

# res.list is a named list. Each item should be a list with names c('res',
# 'dds', 'label'). "res" is a DESeqResults object, "dds" is the corresponding
# DESeq object the results were extracted from, and "label" is a nicer label to
# use for headers and other text.
res.list <- list()

# NOTE: Example contrast #1----------------------------------------------------
#   Using the example data, this compares treatment group to control group.
#   Change to reflect your experiment.
# IMPORTANT: Control must always be last
res.list[['all']] <- list(
    res=lfcShrink(dds, contrast=c('group', 'treatment', 'control'), type='normal'),
    dds=dds,
    label='Using a log2FoldChange threshold of 0'
)


# NOTE: Example contrast #2----------------------------------------------------
#    Using the example data, this compares treatment group to control group but
#    requiring genes to have >4-fold differences (log2(4) = 2). Change to
#    reflect your experiment.
#    If using an lfcThreshold, must update elsewhere throughout the code.
res.lfcthresh.2 <- results(
    dds,
    contrast=c('group', 'treatment', 'control'),
    lfcThreshold=2)

res.list[['lfc2']] <- list(
    res=lfcShrink(
        dds,
        contrast=c('group', 'treatment', 'control'),
        res=res.lfcthresh.2,
        type='normal'
    ),
    dds=dds,
    label='Using a log2FoldChange threshold of >2'
)
```


```{r attach, cache=TRUE, dependson='results'}
# NOTE: Assumes Ensembl Ids----------------------------------------------------
keytype <- 'ENSEMBL'

# NOTE: Assumes these  columns are available in the OrgDb----------------------
columns <- c('SYMBOL', 'UNIPROT', 'ALIAS')

for (name in names(res.list)){
    res.list[[name]][['res']] <- attach.info(
        res.list[[name]][['res']],
        keytype=keytype,
        columns=columns)
}
```

# Differential expression {.tabset}

```{r}
# NOTE: significance level---------------------------------------------------
alpha <- 0.1
lfc.thresh <- 0 # Must change if using an lfcThreshold other than 0
```

Here is a table summarizing the comparisons. See the [Background and
help](#Help) section for details.

```{r, results='asis'}
# Summarize all experiments
knitr::kable(summarize.res.list(res.list, alpha, lfc.thresh))
```

For each comparison there is a tab and under each tab are the following:

- summary of results (the line from the summary table above for this comparison)
- Normalized counts plots for the top 3 upregulated genes
- Normalized counts plots for the top 3 down-regulated genes
- an M-A plot
- a p-value histogram


See the [Background and help](#Help) section for details on these.


```{r, results='asis'}
# NOTE: Which columns to add to the top plots' titles?-------------------------
#    This will add nicer titles to the plots. These may have come from the
#    `attach.info` call above.
add_cols <- c('symbol', 'alias')

for (name in names(res.list)){
  dds.i <- res.list[[name]][['dds']]
  res.i <- res.list[[name]][['res']]
  label <- res.list[[name]][['label']]

  mdcat('## ', label, ' {.tabset}')
  mdcat('### Summary of results')
  print(knitr::kable(my.summary(res.i, dds.i)))
  mdcat('### Normalized counts of top 3 upregulated genes')
  print(counts.plot(counts.df(dds.i, res.i, sel.genes=lfc.filter(res.i),
                              label='symbol', rank.col='padj'),
                    3))
  mdcat('### Normalized counts of top 3 downregulated genes')
  print(counts.plot(counts.df(dds.i, res.i, sel.genes=lfc.filter(res.i, reverse=TRUE),
                              label='symbol', rank.col='padj'),
                    3))

  # NOTE: gene labels --------------------------------------------------------
  #   By default we plot the symbols of the top 10 upregulated or downregulated
  #   genes, with the lowest padj. To change this behavior edit the following
  #   lines
  res.i <- res.i[order(res.i$padj),]

  genes.to.label <- res.i[1:10, 'symbol']

  mdcat('### M-A plot')
  print(plotMA.label(res.i, genes.to.label=genes.to.label, col='symbol'))

  mdcat('### P-value distribution')
  pval.hist(res.i)
}
```

```{r selections, cache=TRUE, dependson='attach'}
sel.list <- list()
for (name in names(res.list)){
  res <- res.list[[name]][['res']]


  # NOTE: any other selections?------------------------------------------------
  #    Here we just get the up- and downregulated genes, but any arbitrary
  #    subsets of the results can be added.
  #
  #    For each selection:
  #      - TSV of the subset of genes will be written to file and a link
  #        created for it in the Markdown
  #      - GO analysis will be performed on each group separately below.
  sel.list[[name]] <- list(
    up=res[get.sig(res, alpha=alpha, lfc.thresh=lfc.thresh, direction='up'),],
    dn=res[get.sig(res, alpha=alpha, lfc.thresh=lfc.thresh, direction='dn'),]
    )
}

# Keep track of our sel.list entries, here just using the last one
sel.names <- names(sel.list[[name]])
```

```{r upsetplots, results='asis', cache=TRUE, dependson='selections'}
# UpSet plots only make sense for more than one set of genes. The Markdown
# explanatory text and the plots themselves are only created if res.list has
# multiple items in it.

plot.upset <- function(sel.list.key, label) {
    mdcat("## UpSet plot: ", label)
    ll <- lapply(sel.list, function (x) rownames(x[[sel.list.key]]))
    ll <- ll[lapply(ll, length) > 0]
    if (length(ll) > 1) {
        print(upset(fromList(ll), order.by='freq', nsets=length(ll)))
        outfile <- file.path('upset_plots', paste0(label, '.tsv'))
        lldf <- rownames.first.col(fromList.with.names(ll))
        write.table(lldf, file=outfile, sep='\t', row.names=FALSE)
        mdcat('- [', outfile, ']', '(', outfile, ')')
        pdf.file <- file.path('upset_plots', paste0(label, '.pdf'))
        dev.copy(pdf, file=pdf.file)
        dev.off()
        mdcat('- [', pdf.file, ']', '(', pdf.file, ')')

    } else {
        mdcat('not enough contrasts with upregulated genes')
    }
}


if (length(res.list) > 1){

    dir.create('upset_plots', showWarnings=FALSE)

    mdcat("# UpSet plots {.tabset}")
    mdcat("Here we gather together all the interesting gene sets into an ",
          "[UpSet plot](http://caleydo.org/tools/upset/). These plots show ",
          "the combinatorial overlaps of genes found to be up or down ",
          "across the different contrasts performed. It's much like a ",
          "Venn diagram, but easier to interpret and can scale to many comparisons. ",
          "A TSV file is linked under each plot. This file has rows for each ",
          "gene and columns for each contrast. A `1` indicates that gene was found to be ",
          "up/down/changed in that contrast. "
    )

    for (name in names(sel.list[[1]])){
        plot.upset(name, name)
    }
}
```

```{r child='gene-patterns.Rmd', eval=TRUE}
rmarkdown::render('gene-patterns.Rmd', run_pandoc=FALSE)
```

# Exported results

The files below are TSVs that can be opened in Excel:


```{r, results='asis'}
# Write out files for full and each selection, and create a link to them in the
# HTML generated by this RMarkdown.
for (name in names(res.list)){
  mdcat('## ', res.list[[name]][['label']])
  fn <- paste0(name, '.tsv')
  write.table(res.list[[name]][['res']], file=fn, row.names=FALSE, sep='\t')
  mdcat('- [', fn, '](', fn, '), results for ', res.list[[name]][['label']])
}
```

```{r child='functional-enrichment.Rmd', eval=TRUE}
rmarkdown::render('functional-enrichment.Rmd', run_pandoc=FALSE)
```

# Session info
For reproducibility purposes, here is the output of `sessionInfo()` showing the
versions of all packages used here.

```{r, collapse=FALSE}
sessionInfo()
```

# Help

```{r helpdocs, child="help_docs.Rmd", run_pandoc=FALSE}
# NOTE: optional help section--------------------------------------------------
#   Delete this chunk, or set to eval=FALSE, if you don't want to include the
#   help text from "help_docs.Rmd"
```
