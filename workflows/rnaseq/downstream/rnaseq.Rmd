
```{r, include=FALSE}
#-----------------------------------------------------------------------------
# NOTES:
#
# This Rmd file aims to include "the works", with some preliminary exploratory
# visualizations, followed by differential expression using both gene models
# and transcript models (with examples of interaction) SVA, and some downstream
# GO analysis.
#
# Assumptions are indicated where they are made, so look for those comments
# starting with "Assumptions:" identify places that may need some editing.
# Notably, the only model run by default is `~group`, which will only be
# appropriate for the simplest experiments.

# There are a fair amount of helper functions. In order to keep this file
# self-contained and easier to edit on a case-by-case basis, they are included
# inline here.

#-----------------------------------------------------------------------------
```

```{r, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, warning=FALSE, message=FALSE,
                      bootstrap.show.code=FALSE, bootstrap.show.output=FALSE,

                      # try disabling this when running locally for nicer figures
                      #dev='bitmap',

                      fig.ext='png')
```
# Track hub

Click the following link to load the track hub (and prepared session) on the UCSC genome browser:

[Load hub and prepared session on UCSC Genome Browser](http://genome.ucsc.edu/cgi-bin/hgTracks?db=ASSEMBLY&hubUrl=https://HOST/PATH/hub.txt&hgS_loadUrlName=https://HOST/PATH/session.txt&hgS_doLoadUrl=submit&position=chr1:1-100)

# Differential expression

Note: if you're unfamiliar with any of the plots or tables here, see the
[Background and help](#background) section for details.

## Experiment overview

```{r imports}
library(DESeq2)
library(gridExtra)
library(ggplot2)
library(genefilter)
library(readr)
library(tximport)
library(clusterProfiler)
library(AnnotationHub)
```

```{r child='helpers.Rmd'}
# When running interactively, use the following to load helper functions.
# When rendering this file, the contents of this code block will be skipped.
rmarkdown::render('helpers.Rmd')
```

```{r annotationhub_setup}
# Try disabling this when running locally to get nicer figures:
# options(bitmapType='cairo')

# Assumption: change these to reflect organism you're working with.
# e.g., 'Mus musculus', 'mmu'; 'Homo sapiens', 'hsa'. Provide an annotation key
# to override if you know the one to use, otherwise leave NA.
annotation_genus_species <- 'Drosophila melanogaster'
kegg.org <- 'dme'
hub.cache <- '../../../include/AnnotationHubCache'
annotation_key_override <- NA

# For running on the cluster, we copy to faster tmp storage to avoid poor
# sqlite performance on shared filesystems.
file.copy(hub.cache, tempdir(), recursive=TRUE)
new.cache <- file.path(tempdir(), 'AnnotationHubCache')

orgdb <- get.orgdb(
    annotation_genus_species,
    cache=new.cache,
    annotation_key_override=annotation_key_override
)
```

```{r coldata_setup}
# Assumption: path name to sampletable
sample.table.filename = '../config/sampletable.tsv'

colData <- read.table(sample.table.filename, sep='\t', header=TRUE)

# Assumption: data directory and extension to featurecounts output
colData$featurecounts.path <- sapply(
    colData$samplename,
    function (x) file.path('..', 'data', 'rnaseq_samples', x, paste0(x, '.cutadapt.bam.featurecounts.txt')
                           )
    )

# Assumption: data directory and salmon filenames
colData$salmon.path <- sapply(
    colData$samplename,
    function (x) file.path('..', 'data', 'rnaseq_samples', x, paste0(x, '.salmon'), 'quant.sf')
)

# Assumption: which columns in sampletable, and that "group" should be factor
factor.columns <- c('group')
exclude.for.printing <- c('featurecounts.path', 'salmon.path', 'orig_filename')
colData$group <- paste(colData$condition)
for (col in factor.columns){
    colData[[col]] <- as.factor(colData[[col]])
}

# Assumption: "control" is the base level for the group factor
colData$group <- relevel(colData$group, ref='control')
knitr::kable(colData[, colnames(colData)[!colnames(colData) %in% exclude.for.printing]])
```

```{r ddstxi, cache=TRUE, eval=FALSE}
# Assumption: eval=FALSE by default. Change to eval to TRUE to run this.

# Load transcript-level counts
dds.txi <- DESeqDataSetFromSalmon(
                                  sampleTable=colData,
                                  directory='.',
                                  # Assumption: what to model
                                  design=~condition)
# rlog normalize transcript counts
rld.txi <- rlog(dds.txi, blind=FALSE)
```


```{r dds_initial, cache=TRUE}
# Load gene-level counts
dds <- DESeqDataSetFromFeatureCounts(
    sampleTable=colData,
    directory='.',
    # Assumption: what to model.
    # Used for EDA, so it's recommended to use a single factor that describes
    #condition
    design=~group)

# Assumption: If gene names came in as Ensembl "gene.version" IDs, here we
# split them to only give the gene ID.
rownames(dds) <- sapply(strsplit(rownames(dds), '.', fixed=TRUE), function (x) x[1])

# rlog normalize gene-level counts
rld <- rlog(dds, blind=FALSE)
```

## Sample clustering and QC

The following heatmap shows a hierarchical clustering of pairwise distances
between samples. Darker blue means less distant (i.e. more similar). In general
we expect to see replicates clustering together and separation of treatments.

## Clustered heatmap

```{r}
plot.heatmap(rld, colData, c('group'))
```

## PCA

Another way of looking at sample clustering is principal components analysis
(PCA). The x- and y-axes do not have units, rather, they represent the
dimensions along which the samples vary the most. The amount of variance
explained by each principal component is indicated in the axes label.


```{r}
# Assumption: gene-level counts
# Assumption: color by 'group' factor
plotPCA(rld, intgroup=c('group'))
```


## Most-varying genes

We can also look at the most varying genes to get a sense of the clustering.
This heatmap takes the top 50 most-varying genes and plots their deviation from
the row mean.


```{r, fig.height=12}
vargenes.heatmap(rld, c('group'))
```

```{r dds_models, cache=TRUE}
dds <- DESeqDataSetFromFeatureCounts(
    sampleTable=colData,
    directory='.',
    # Assumption: model to use
    design=~group,

    # Assumption: this the default for versions of DESeq2 > 1.16. We set it
    # explicitly here for consistency.
    betaPrior=FALSE
    )

# Assumption: If gene names came in as Ensembl "gene.version" IDs, here we
# split them to only give the gene ID.
rownames(dds) <- sapply(strsplit(rownames(dds), '.', fixed=TRUE), function (x) x[1])
dds <- DESeq(dds)
```

```{r results, cache=TRUE}
# Results are put in a list here so we can iterate over them later. Names here
# will be used to create output files.
res.list <- list(
                 all=lfcShrink(dds, contrast=c('group', 'treatment', 'control')),
                 )
dds.list <- list(
                 all=dds
                 )
res.list.lookup <- list(
                        all="All replicates"
                        )
```

```{r}
#' Plot a gene's normalized counts across samples
#'
#' @param gene Gene ID
#' @param dds DESeq object from which to extract counts
#'
my.counts <- function(gene, dds, label=NULL){

  # Assumption: color genes by group
  geneCounts <- plotCounts(dds, gene=gene, intgroup=c('group'), returnData=TRUE)
  p <- ggplot(geneCounts, aes(x=group, y=count, color=group, group=group)) +
    scale_y_log10() +
    geom_point(position=position_jitter(width=.1, height=0),  size=3) +
    geom_line(color='#000000') +
    ggtitle(gene)

  if (!is.null(label)){
    p <- p + ggtitle(label)
  }
  return(p)
}

#' Re-order results by log2FoldChange
#'
#' @param res DESeq2 results object
#' @param reverse If TRUE then sort high-to-low
lfc.order <- function(res, reverse=FALSE){
    res.na <- res[!is.na(res$log2FoldChange),]
    if (!reverse){
        return(res.na[order(res.na$log2FoldChange),])
    }
    if (reverse){
        return(res.na[rev(order(res.na$log2FoldChange)),])
    }
}

#' Re-order results by adjusted pval
#'
#' @param res DESeq2 results object
#' @param reverse If TRUE then sort high-to-low
padj.order <- function(res, reverse=FALSE){
    res.na <- res[!is.na(res$log2FoldChange) & !is.na(res$log2FoldChange),]
    if (!reverse){
        res.na <- res.na[res.na$log2FoldChange > 0,]
    } else {
        res.na <- res.na[res.na$log2FoldChange < 0,]
    }
    return(res.na[order(res.na$padj),])
}


#' Plot normalized gene counts for the top N genes
#'
#' @param sorted DESeq2 results object
#' @param n Number of top genes to plot
#' @param func Plotting function to call on each gene
#' @param dds DESeq2 object
#' @param label Vector of column names in `res` from which to add a label to
#'   the gene (e.g., c('symbol', 'alias'))
top.plots <- function(res, n, func, dds, add_cols=NULL){
    ps <- list()
    for (i in seq(n)){
        gene <- rownames(res)[i]
        add_label <- as.character(as.data.frame(res)[i, add_cols])
        add_label <- add_label[!is.na(add_label)]
        label <- paste(gene, add_label, sep=' | ')
        if (length(label) == 0){
          label <- NULL
        }
        ps[[gene]] <- func(gene, dds, label=label)
    }
    grid.arrange(grobs=ps)
}

#' Plot a histogram of raw pvals
#'
#' @param res DESeq2 results object
pval.hist <- function(res){
    hist(res$pvalue[res$baseMean>1], breaks=0:20/20, col='grey50', border='white', xlab='P-value', main='Distribution of p-values')
}

#' Summarize DESeq2 results into a dataframe
#'
#' summary(res) prints out info; this function captures it into a dataframe
#'
#' @param res DESeq2 results object
#' @param dds DEseq2 object
#' @param alpha Alpha level at which to call significantly changing genes
my.summary <- function(res, dds, alpha, ...){
   if (missing(alpha)){
       alpha <- if (is.null(metadata(res)$alpha)){ 0.1 } else { metadata(res)$alpha }
        notallzero <- sum(res$baseMean > 0)
   }
   up <- sum(res$padj < alpha & res$log2FoldChange > 0, na.rm=TRUE)
   down <- sum(res$padj < alpha & res$log2FoldChange < 0, na.rm=TRUE)
   filt <- sum(!is.na(res$pvalue) & is.na(res$padj))
   outlier <- sum(res$baseMean > 0 & is.na(res$pvalue))
   ft <- if(is.null(metadata(res)$filterThreshold)){ 0 } else { round(metadata(res)$filterThreshold) }
   df <- data.frame(
                    total.annotated.genes=nrow(res),
                    total.nonzero.read.count=notallzero,
                    alpha=alpha,
                    up=up,
                    down=down,
                    outliers=outlier,
                    low.counts=filt,
                    design=deparse(design(dds))
                    )
   return(df)
}

```
```{r}
# Attach other info to results

for (name in names(res.list)){
  res <- res.list[[name]]
  keys <- sapply(strsplit(rownames(res), '.', fixed=TRUE), function (x) x[1])

  # Assumption: Original annotations use Ensembl IDs
  keytype <- 'ENSEMBL'

  # Assumption: Uniprot and Alias columns are available in the OrgDb
  columns <- c('SYMBOL', 'UNIPROT', 'ALIAS')

  for (column in columns){
    label <- tolower(column)
    res[label] <- mapIds(orgdb, keys=keys, column=column, keytype=keytype, multiVal='first')
  }

  # Put "gene" column as the first
  cn <- colnames(res)
  res$gene <- rownames(res)
  res <- res[, c('gene', cn)]
  res.list[[name]] <- res
}
```

# Differential expression

```{r, results='asis'}
# Assumption: which columns to add to the top plots' titles
add_cols <- c('symbol', 'alias')
for (name in names(res.list)){
  mdcat('## ', res.list.lookup[[name]])
  mdcat('### Summary of results')
  res <- res.list[[name]]
  print(knitr::kable(my.summary(res, dds)))
  mdcat('### Normalized counts of top 3 upregulated genes')
  top.plots(padj.order(res), 3, my.counts, dds, add_cols)
  mdcat('### Normalized counts of top 3 downregulated genes')
  top.plots(padj.order(res, reverse=TRUE), 3, my.counts, dds, add_cols)
  mdcat('### M-A plot')
  plotMA(res)
  mdcat('### P-value distribution')
  pval.hist(res)
}
```

# Exported results

```{r}
# Subset out up/down regulated. Other selections can be added, and
# corresponding output files will be created and GO analysis will be performed
# on them below.
#
# sel.list will be a list of lists of subsets of the original results in
# res.list; access selections with, e.g., sel.list[['experiment1]'][['up']]
sel.list <- list()
for (name in names(res.list)){
  res <- res.list[[name]]

  # Assumption: significance level
  alpha <- 0.1
  sel.list[[name]] <- list(
    up=res[(res$padj < alpha) & (res$log2FoldChange > 0) & !is.na(res$padj) & !is.na(res$log2FoldChange),],
    dn=res[(res$padj < alpha) & (res$log2FoldChange < 0) & !is.na(res$padj) & !is.na(res$log2FoldChange),]
  )
}
```

```{r, results='asis'}
# Write out files for full and each selection
for (name in names(res.list)){
  mdcat('## ', res.list.lookup[[name]])
  fn <- paste0(name, '.tsv')
  write.table(res.list[[name]], file=fn, row.names=FALSE, sep='\t')
  mdcat('- [', fn, '](', fn, '), results for ', res.list.lookup[[name]])
  for (sel in names(sel.list[[name]])){
    fn <- paste0(name, '.', sel, '.tsv')
    write.table(sel.list[[name]][[sel]], file=fn, row.names=FALSE, sep='\t')
    mdcat('- [', fn, '](', fn, '), just the "', sel, '" genes for ', res.list.lookup[[name]])
  }
}
```

# Gene ontology and KEGG pathway enrichment

Here we perform gene ontology enrichment and KEGG pathway enrichment using the
[clusterProfiler](https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html)
package with some custom plotting functions.

```{r}
# These are some helper functions for working with clusterProfiler results.
# While clusterProfiler does a great job of unifying the output of different
# enrichment metrics into a single data structure, we need a couple more things
# for very flexibly plotting with ggplot2. These functions handle the enrichment
# and summary of results.

#' Run enrichGO on each of the three top-level ontologies
#'
#' @param genes Gene IDs with format matching `keytype`
#' @param univers Universe of genes assayed
#' @param orgdb String or OrgDb object
#' @param keytype ID type of genes
#"
#' @return  List of clusterProfiler output objects, length 3 where names are
#' ontologies (BP, MF, CC)
clusterprofiler.enrichgo <- function(genes, universe, orgdb, keytype='ENSEMBL'){
    lst <- list()
    if (length(genes) > 0 ){
        for (ont in c('BP', 'MF', 'CC')){
            ggo <- enrichGO(gene=genes, ont=ont, universe=universe,
                            OrgDb=orgdb, keyType=keytype, pAdjustMethod='BH',
                            pvalueCutoff=0.01, qvalueCutoff=0.05,
                            readable=TRUE)
            lst[[ont]] <- ggo
        }
    }
    return(lst)
}

#' Run KEGG enrichment
#'
#' @param genes Gene IDs typically in UniProt format
#' @param org 3-character KEGG species ID (dme, hsa, mmu)
#' @param keytype ID type of genes
#'
#' @return clusterProfiler output object
clusterprofiler.enrichkegg <- function(genes, org, keyType='uniprot'){
    x <- enrichKEGG(gene=genes, organism=org, keyType='uniprot',
                    pvalueCutoff=0.05)
    return(x)
}

#' Convert "1/100" to 0.01.
#'
#' clusterProfiler report columns that are strings of numbers; this converts to
#' a fraction
#'
#' @param x Character vector to convert
get.frac <- function(x){
    y <- as.numeric(strsplit(x, '/')[[1]])
    return(y[[1]] / y[[2]])
}

#' Summarize and aggregate multiple GO results
#'
#' Convert a list of GO analysis results (one per ontology) to a single
#' dataframe, with additional label column filled in with `label` and with
#' a fraction column.
#'
#' @param ego List of clusterProfiler results objects
#' @param labels List of labels. For each name, a new column will be added and
#"        its contents will be the value
#'
#' @return dataframe
summarize.go <- function(ego, labels){
  lst <- list()
  for (name in names(ego)){
    d <- as.data.frame(ego[[name]])
    if (nrow(d) > 0){
      d$ontology <- name
      for (label in names(labels)){
        d[label] <- labels[[label]]
      }
      d$frac <- sapply(d$GeneRatio, get.frac)
    }
    lst[[name]] <- d
  }
  df <- do.call(rbind, lst)
  return(df)
}


#' Summarize KEGG results
#'
#' Summarize KEGG results and add `frac` and `label` columns
#'
#' @param ekg Results from clusterProfiler KEGG enrichment
#' @param label Attach this label to the "label" column
#'
#' @return Dataframe
summarize.kegg <- function(ekg, labels){
  d <- as.data.frame(ekg)
  if (nrow(d) > 0){
    d$ontology <- 'kegg'
    for (label in names(labels)){
      d[label] <- labels[[label]]
    }
    d$frac <- sapply(d$GeneRatio, get.frac)
  }
  return(d)
}
```

```{r, cache=TRUE}
# Here we summarize the results into dataframes and attach additional
# information to them such that they can be concatenated together into a large
# tidy dataframe.
universe <- names(dds)
enrich.list <- list()
for (name in names(sel.list)){
  for (sel in names(sel.list[[name]])){
    sel.res <- sel.list[[name]][[sel]]

    # GO enrichment
    go.label <- paste(name, sel, 'go', sep='.')
    message(paste(go.label, '...'))
    sg <- summarize.go(
      clusterprofiler.enrichgo(sel.res$gene, universe, orgdb),
      list(label=go.label, sel=sel, experiment=name))
    if (!is.null(sg)){
      enrich.list[[go.label]] <- sg
    }

    # KEGG enrichment
    kegg.label <- paste(name, sel, 'kegg', sep='.')
    message(paste(kegg.label, '...'))
    sk <- summarize.kegg(
      clusterprofiler.enrichkegg(sel.res$uniprot, kegg.org),
      list(label=kegg.label, sel=sel, experiment=name))
    if (!is.null(sk)){
      enrich.list[[kegg.label]] <- sk
    }
  }
}
```

These plots show:

- enriched category (y-axis)
- magnitude of enrichment (x-axis; plotted as -10 log10 (FDR) or "phred" scale)
- fraction of regulated genes falling within a particular category (size)
- experiment (color)
- ontology (sub-panels; BP=biological process, MF=molecular function,
  CC=cellular component, kegg=KEGG pathway)
- direction of regulation (up- or downregulated; separate figures; labeled at the top)

The plots show the top 50 terms, and are sorted by the max enrichment across
experiments.

```{r}
full.enrich.table <- do.call(rbind, enrich.list)
write.table(full.enrich.table, file='functional_enrichment.tsv', row.names=FALSE, sep='\t')
```

The full analysis table can be viewed here:

- [functional_enrichment.tsv](functional_enrichment.tsv)

```{r, go, fig.height=15, dev=c('pdf', 'png')}
# While clusterProfiler has canned figures, it's difficult to customize them.
# Instead, here we create a tidy dataframe of all experiments, directions, and
# enrichment analyses so that we can plot them with ggplot2 however the
# experiment dictates


lim <- 50
nchunks <- 1

# Assumption: all experiments have the same selections
for (sel in names(sel.list[[1]])){
  mdcat('## ', sel)
  m <- do.call(rbind, enrich.list)

  ###compute description length distribution for entire ontology
  length.quantile <- quantile(nchar(as.vector(m$Description, mode="character")), 0.75)


  # convert to phred score, and flip the "downregulated"
  m$phred <- -10 * log10(m$p.adjust)
  idx <- m$sel == sel

  m <- m[idx,]

  if (nrow(m) == 0){next}

  # Grab the top (ordered by phred)
  m$Description <- factor(m$Description)
  max.per.term <- aggregate(phred~Description, m, FUN=max)
  o <- rev(order(max.per.term$phred))
  m$Description <- factor(m$Description, levels=rev(max.per.term$Description[o]))
  top.terms <- (max.per.term$Description[o][seq(lim)])
  m.sub <- m[m$Description %in% top.terms,]
  m.sub$Description <- droplevels(m.sub$Description)
  m.sub <- m.sub[order(m.sub$Description),]

  chunksize <- ceiling(lim / nchunks)
  lookup <- rep(1:nchunks, each=chunksize)
  m.sub$chunk <- 0
  for (i in seq(length(lookup))){
    term <- as.character(top.terms[i])
    lab <- lookup[i]
    m.sub$chunk[m.sub$Description == term] = lab
  }

  #replace ontology descriptions with truncations to make plot prettier
  temp.desc <- as.vector(m.sub$Description, mode="character")
  needs.replacement <- which(nchar(temp.desc) > length.quantile)
  temp.desc <- strtrim(temp.desc, length.quantile)
  temp.desc[needs.replacement] <- paste(temp.desc[needs.replacement], "...", sep="")
  m.sub$Description <- factor(temp.desc)

print(ggplot(m.sub) +
    geom_point(alpha=0.6) +
    aes(y=Description, x=phred, size=frac, color=experiment) +
    theme(text=element_text(size=12)) +
    facet_grid(ontology~sel, scales='free_y', space='free_y')
  )
}
```

