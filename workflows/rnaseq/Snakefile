import sys
sys.path.insert(0, srcdir('../..'))
import os
from textwrap import dedent
import yaml
import tempfile
import pandas as pd
from lcdblib.snakemake import helpers, aligners
from lcdblib.utils import utils
from lib import common
from lib import cluster_specific
from lib.patterns_targets import RNASeqConfig
import copy

# ----------------------------------------------------------------------------
#
# Search for the string "NOTE:" to look for points of configuration that might
# be helpful for your experiment.
#
# ----------------------------------------------------------------------------

# Only use default if no configfile specified on the command line with
# --configfile
if not workflow.overwrite_configfile:
    configfile: 'config/config.yaml'
else:
    configfile: workflow.overwrite_configfile

include: '../references/Snakefile'
shell.prefix('set -euo pipefail; export TMPDIR={};'.format(cluster_specific.tempdir_for_biowulf()))
shell.executable('/bin/bash')

config = common.load_config(config)

c = RNASeqConfig(config, config.get('patterns', 'config/rnaseq_patterns.yaml'))

wildcard_constraints:
    n = '[1,2]'


def wrapper_for(path):
    return 'file:' + os.path.join('../..','wrappers', 'wrappers', path)


# ----------------------------------------------------------------------------
# RULES
# ----------------------------------------------------------------------------

report: "report/workflow.rst"

def targets(p):
    # See "patterns and targets" in the documentation for what's going on here.
    final_targets = utils.flatten((
        c.targets['bam'][p],
        utils.flatten(c.targets['fastqc'][p]),
        utils.flatten(c.targets['libsizes'][p]),
        [c.targets['fastq_screen'][p]],
        [c.targets['libsizes_table'][p]],
        [c.targets['rrna_percentages_table'][p]],
        [c.targets['multiqc'][p]],
        utils.flatten(c.targets['featurecounts'][p]),
        utils.flatten(c.targets['rrna'][p]),
        utils.flatten(c.targets['markduplicates'][p]),
        utils.flatten(c.targets['salmon'][p]),
        utils.flatten(c.targets['dupradar'][p]),
        utils.flatten(c.targets['preseq'][p]),
        utils.flatten(c.targets['rseqc'][p]['bam_stat']),
        utils.flatten(c.targets['collectrnaseqmetrics'][p]),
        utils.flatten(c.targets['bigwig'][p]),
        utils.flatten(c.targets['downstream'][p]),
    ))

    if 'merged_bigwigs' in config:
        final_targets.extend(utils.flatten(c.targets['merged_bigwig'][p]))

    # Special case: all samples are single-end
    if all(c.sampletable.iloc[:, 0].apply(
        lambda x: not common.is_paired_end(c.sampletable, x))
    ):
        ALL_SE = True
        final_targets = [i.replace('{n}', '1') for i in final_targets]
    else:
        ALL_SE = False
    return (final_targets, ALL_SE, c.sampletable)

final_targets, ALL_SE, c.sampletable = targets('pattern')


final_rst = copy.deepcopy(c.patterns)
rstpaths = []
for key, val in final_rst.items():
    if type(val['pattern']) is not dict:
        val['pattern'] = val['pattern'].replace('{', '_').replace('}', '_')
        final_rst[key]['pattern'] = 'report/' + val['pattern'] + '.rst'
        rstpaths.append(final_rst[key]['pattern'])
    elif type(val['pattern']) is dict:
        for nestkey, nestval in val['pattern'].items():
           nestval= nestval.replace('{', '_').replace('}', '_')
           final_rst[key]['pattern'][nestkey] = 'report/' + nestval + '.rst'
           rstpaths.append(final_rst[key]['pattern'][nestkey])

rule targets:
    """
    Final targets to create
    """
    input:
        final_targets,
        rstpaths

rule report_rst:
    """
    Create .rst containing captions for report
    """
    input: 
        'config/rnaseq_patterns.yaml'
    output: 
        rstpaths
    run:
        for key, val in final_rst.items():
            if type(val['description']) is not dict:
                descr = val['description']
                pat = val['pattern']
                shell("echo {descr} > {pat}")
            elif type(val['description']) is dict:
                for nestkey, nestval in val['description'].items():
                    descr = val['description'][nestkey]
                    pat = val['pattern'][nestkey]
                    shell("echo '{descr}' > {pat}")


if 'orig_filename' in c.sampletable.columns:

    # Convert the sampletable to be indexed by the first column, for
    # convenience in generating the input/output filenames.
    _st = c.sampletable.set_index(c.sampletable.columns[0])

    def orig_for_sample(wc):
        """
        Given a sample, returns either one or two original fastq files
        depending on whether the library was single- or paired-end.
        """
        row = _st.loc[wc.sample]
        res = [row['orig_filename']]
        try:
            r2 = row['orig_filename_R2']
            if isinstance(r2, str):
                res.append(row['orig_filename_R2'])
        except KeyError:
            pass
        return res

    rule symlinks:
        """
        Symlinks files over from original filename
        """
        input:
            orig_for_sample
        output:
            c.patterns['fastq']['pattern']
        wildcard_constraints:
            n="\d+"
        run:
            for src, linkname in zip(input, output):
                utils.make_relative_symlink(src, linkname)


    rule symlink_targets:
        input: c.targets['fastq']['pattern']


def render_r1_r2(pattern):
    if ALL_SE:
        return expand(pattern, sample='{sample}', n=[1])
    return expand(pattern, sample='{sample}', n=[1, 2])


if 'Run' in c.sampletable.columns and sum(c.sampletable['Run'].str.startswith('SRR')) > 0:

    # Convert the sampletable to be indexed by the first column, for
    # convenience in generating the input/output filenames.
    _st = c.sampletable.set_index(c.sampletable.columns[0])

    rule fastq_dump:
        output:
            fastq=render_r1_r2(c.patterns['fastq']['pattern'])
        run:
            srr = _st.loc[wildcards.sample, 'Run']

            # Two different paths depending on the layout. In both cases, we
            # want to avoid creating the final output until the very end, to
            # avoid incomplete downloads.
            if common.is_paired_end(c.sampletable, wildcards.sample):

                # For PE we need to use --split-files, which also means using
                # the slower --gzip
                shell(
                    'fastq-dump '
                    '{srr} '
                    '--gzip '
                    '--split-files '
                    # '-X 100000 ' # [TEST SETTINGS]
                )

                # The filenames are predictable, so we can move them as needd.
                shell('mv {srr}_1.fastq.gz {output[0]}')
                shell('mv {srr}_2.fastq.gz {output[1]}')

            else:
                # For SE, we can use the faster stdout | gzip, and move it
                # directly when done.
                shell(
                    'fastq-dump '
                    '{srr} '
                    '-Z '
                    # '-X 100000 ' # [TEST SETTINGS]
                    '| gzip -c > {output[0]}.tmp '
                    '&& mv {output[0]}.tmp {output[0]} '
                )
                if not ALL_SE:
                    shell('touch {output[1]}')


rule cutadapt:
    """
    Run cutadapt
    """
    input:
        fastq=common.fill_r1_r2(c.sampletable, c.patterns['fastq']['pattern'])
    output:
        fastq=report(render_r1_r2(c.patterns['cutadapt']['pattern']), caption=
            final_rst['cutadapt']['pattern'],
                     category="fastq")
    log:
        render_r1_r2(c.patterns['cutadapt']['pattern'])[0] + '.log'
    run:
        paired = len(input) == 2

        # NOTE: Change cutadapt params here
        extra='-a file:../../include/adapters.fa -q 20 --minimum-length=25'

        if paired:
            shell(
                "cutadapt "
                "{extra} "
                "{input.fastq[0]} "
                "{input.fastq[1]} "
                "-o {output[0]} "
                "-p {output[1]} "
                "&> {log}"
            )
        else:
            shell(
                "cutadapt "
                "{extra} "
                "{input.fastq[0]} "
                "-o {output[0]} "
                "&> {log}"
            )
            if not ALL_SE:
                shell('touch {output[1]}')


rule fastqc:
    """
    Run FastQC
    """
    input: '{sample_dir}/{sample}/{sample}{suffix}'
    output:
        html='{sample_dir}/{sample}/fastqc/{sample}{suffix}_fastqc.html',
        zip='{sample_dir}/{sample}/fastqc/{sample}{suffix}_fastqc.zip',
    script:
        wrapper_for('fastqc/wrapper.py')


if config['aligner']['index'] == 'hisat2':
    rule hisat2:
        """
        Map reads with HISAT2
        """
        input:
            fastq=common.fill_r1_r2(c.sampletable, c.patterns['cutadapt']['pattern']),
            index=[c.refdict[c.organism][config['aligner']['tag']]['hisat2']]
        output:
            bam=c.patterns['bam']['pattern']
        log:
            c.patterns['bam']['pattern'] + '.log'
        params:
            # NOTE: see examples at
            # https://github.com/lcdb/lcdb-wf/tree/master/wrappers/wrappers/hisat2/align
            # for details on setting hisat2 params and samtools params separately.
            samtools_view_extra='-F 0x04'
        threads: 6
        script:
            wrapper_for('hisat2/align/wrapper.py')

if config['aligner']['index'] == 'star':
    rule star:
        """
        Map reads with STAR
        """
        input:
            fastq=common.fill_r1_r2(c.sampletable, c.patterns['cutadapt']['pattern']),
            index=[c.refdict[c.organism][config['aligner']['tag']]['star']]
        output:
            bam=c.patterns['bam']['pattern']
        log:
            c.patterns['bam']['pattern'] + '.log'
        threads: 6
        run:
            genomedir = os.path.dirname(input.index[0])
            prefix = os.path.dirname(output[0]) + '.star.'
            shell(
                'STAR '
                '--runThreadN {threads} '
                '--genomeDir {genomedir} '
                '--readFilesIn {input.fastq} '
                '--readFilesCommand zcat '
                '--outFileNamePrefix {prefix} '
                # NOTE: The STAR docs indicate that the following parameters
                # are standard options for ENCODE long-RNA-seq pipeline.
                # Comments are from the STAR docs.

                # reduces number of spurious junctions
                '--outFilterType BySJout '

                # if more than this many multimappers, consider unmapped
                '--outFilterMultimapNmax 20 '

                # min overhang for unannotated junctions
                '--alignSJoverhangMin 8 '

                # min overhang for annotated junctions
                '--alignSJDBoverhangMin 1 '

                # max mismatches per pair
                '--outFilterMismatchNmax 999 '

                # max mismatches per pair relative to read length
                '--outFilterMismatchNoverReadLmax 0.04 '

                # min intron length
                '--alignIntronMin 20 '

                # max intron length
                '--alignIntronMax 1000000 '

                # max distance between mates
                '--alignMatesGapMax 1000000 '

                 '&> {log} '
            )

            shell(
                'samtools view '
                '-Sb '
                '-F 0x04 '
                '{prefix}Aligned.out.sam '
                '> {output}.tmp.bam '
                '&& rm {prefix}Aligned.out.sam '
            )
            shell(
                "samtools sort "
                "-o {output.bam} "
                # NOTE: optionally provide other sort arguments here. If you
                # increase threads, you may need to increase memory in the
                # clusterconfig as well.
                "-O BAM "
                "{output}.tmp.bam "
                "&& rm {output}.tmp.bam "
            )

if config['aligner']['index'] == 'ngm':
    rule ngm:
        """
        Map reads with NextGenMap
        """
        input:
            fastq=common.fill_r1_r2(c.sampletable, c.patterns['cutadapt']['pattern']),
            index=[c.refdict[c.organism][config['aligner']['tag']]['ngm']],
            fasta=[c.refdict[c.organism][config['aligner']['tag']]['ngm_fasta']]
        output:
            bam=c.patterns['bam']['pattern']
        log:
            c.patterns['bam']['pattern'] + '.log'
        threads: 6
        run:
            if common.is_paired_end(c.sampletable, wildcards.sample):
                fastqs = '-1 {0} -2 {1} '.format(*input.fastq)
            else:
                fastqs = '--qry {0} '.format(input.fastq)

            prefix = input.index[0].replace('-enc.2.ngm', '')

            output_prefix = output.bam.replace('.bam', '')

            shell(
                "ngm "
                "-r {prefix} "
                "{fastqs} "
                "-t {threads} "
                "-o {output_prefix}.sam "
                # NOTE: add extra NextGenMap options here.
                "&> {log}"
            )

            shell(
                "samtools view -Sb "
                # NOTE: change samtools view arguments here if needed; default
                # is to remove unmapped reads
                "-F 0x04 "
                "{output_prefix}.sam "
                "> {output_prefix}.tmp.bam && rm {output_prefix}.sam"
            )

            shell(
                "samtools sort "
                "-o {output.bam} "
                # NOTE: optionally provide other sort arguments here. If you
                # increase threads, you may need to increase memory in the
                # clusterconfig as well.
                "-O BAM "
                "{output_prefix}.tmp.bam "
                "&& rm {output_prefix}.tmp.bam "
            )


rule rRNA:
    """
    Map reads with bowtie2 to the rRNA reference
    """
    input:
        fastq=common.fill_r1_r2(c.sampletable, c.patterns['cutadapt']['pattern'], r1_only=True),
        index=[c.refdict[c.organism][config['rrna']['tag']]['bowtie2']]
    output:
        bam=c.patterns['rrna']['pattern']['bam']
    log:
        c.patterns['rrna']['pattern']['bam'] + '.log'
    params:
        # NOTE: we'd likely only want to report a single alignment for rRNA
        # screening
        bowtie2_extra='-k 1',
        samtools_view_extra='-F 0x04'
    threads: 6
    script:
        wrapper_for('bowtie2/align/wrapper.py')


rule fastq_count:
    """
    Count reads in a FASTQ file
    """
    input:
        fastq='{sample_dir}/{sample}/{sample}{suffix}.fastq.gz'
    output:
        count='{sample_dir}/{sample}/{sample}{suffix}.fastq.gz.libsize',
    shell:
        'zcat {input} | echo $((`wc -l`/4)) > {output}'


rule bam_count:
    """
    Count reads in a BAM file
    """
    input:
        bam='{sample_dir}/{sample}/{suffix}.bam'
    output:
        count='{sample_dir}/{sample}/{suffix}.bam.libsize',

    shell:
        'samtools view -c {input} > {output}'


rule bam_index:
    """
    Index a BAM
    """
    input:
        bam='{prefix}.bam'
    output:
        bai='{prefix}.bam.bai'
    shell:
        'samtools index {input} {output}'


def fastq_screen_references():
    """
    Returns the Bowtie2 indexes for the configured references from the
    `fastq_screen:` section of the config
    """
    refs = {}
    for i in config['fastq_screen']:
        refs[i['label']] = c.refdict[i['organism']][i['tag']]['bowtie2']
    return refs


rule fastq_screen:
    """
    Run fastq_screen to look for contamination from other genomes
    """
    input:
        **fastq_screen_references(),
        fastq=common.fill_r1_r2(c.sampletable, rules.cutadapt.output.fastq, r1_only=True),
    output:
        txt=report(c.patterns['fastq_screen']['pattern'],
                   caption=final_rst['fastq_screen']['pattern'],
                   category="fastq screen")
    log:
        c.patterns['fastq_screen']['pattern'] + '.log'
    params: subset=100000
    script:
        wrapper_for('fastq_screen/wrapper.py')


rule featurecounts:
    """
    Count reads in annotations with featureCounts from the subread package
    """
    input:
        annotation=c.refdict[c.organism][config['gtf']['tag']]['gtf'],
        bam=c.patterns['bam']['pattern']
    output:
        counts=report('{sample_dir}/{sample}/{sample}.cutadapt.bam.featurecounts.{stranded}.txt',
                      caption=final_rst['bam']['pattern'],
                      category='Feature count')
    log:
        '{sample_dir}/{sample}/{sample}.cutadapt.bam.featurecounts.{stranded}.txt.log'
    shell:
        'featureCounts '

        # NOTE:
        # By default, this rule runs three times, using a different strand
        # setting each time. The strand argument (-s0, -s1, -s2) to
        # featureCounts is pulled straight from the wildcards, and the
        # corresponding filenames have been set up in rnaseq_patterns.yaml.
        #
        # You probably do NOT want to add your own -s argument below, however
        # other arguments might be useful. For example, for nascent RNA-seq,
        # add '-t gene -g gene_id -f '
        '-{wildcards.stranded} '

        # NOTE: additional featureCounts args here
        '-T {threads} '
        '-a {input.annotation} '
        '-o {output.counts} '
        '{input.bam} '
        '&> {log}'


rule rrna_libsizes_table:
    """
    Aggregate rRNA counts into a table
    """
    input:
        rrna=c.targets['rrna']['pattern']['libsize'],
        fastq=c.targets['libsizes']['pattern']['cutadapt']
    output:
        json=report(c.patterns['rrna_percentages_yaml']['pattern'],
                    caption=final_rst['rrna_percentages_yaml']['pattern'],
                    category='Libsizes'),
        tsv=report(c.patterns['rrna_percentages_table']['pattern'],
                   caption=final_rst['rrna_percentages_table']['pattern'],
                   category='Libsizes'),
    run:
        def rrna_sample(f):
            return helpers.extract_wildcards(c.patterns['rrna']['pattern']['libsize'], f)['sample']

        def sample(f):
            return helpers.extract_wildcards(c.patterns['libsizes']['pattern']['cutadapt'], f)['sample']

        def million(f):
            return float(open(f).read()) / 1e6

        rrna = sorted(input.rrna, key=rrna_sample)
        fastq = sorted(input.fastq, key=sample)
        samples = list(map(rrna_sample, rrna))
        rrna_m = list(map(million, rrna))
        fastq_m = list(map(million, fastq))

        df = pd.DataFrame(dict(
            sample=samples,
            million_reads_rRNA=rrna_m,
            million_reads_fastq=fastq_m,
        ))
        df = df.set_index('sample')
        df['rRNA_percentage'] = df.million_reads_rRNA / df.million_reads_fastq * 100

        df[['million_reads_fastq', 'million_reads_rRNA', 'rRNA_percentage']].to_csv(output.tsv, sep='\t')
        y = {
            'id': 'rrna_percentages_table',
            'section_name': 'rRNA content',
            'description': 'Amount of reads mapping to rRNA sequence',
            'plot_type': 'table',
            'pconfig': {
                'id': 'rrna_percentages_table_table',
                'title': 'rRNA content table',
                'min': 0
            },
            'data': yaml.load(df.transpose().to_json()),
        }
        with open(output.json, 'w') as fout:
            yaml.dump(y, fout, default_flow_style=False)


rule libsizes_table:
    """
    Aggregate fastq and bam counts in to a single table
    """
    input:
        utils.flatten(c.targets['libsizes'])
    output:
        json=report(c.patterns['libsizes_yaml']['pattern'],
                   caption=final_rst['libsizes_yaml']['pattern'],
                   category='Libsizes'),
        tsv=report(c.patterns['libsizes_table']['pattern'],
                   caption=final_rst['libsizes_table']['pattern'],
                   category='Libsizes'),

    run:
        def sample(f):
            return os.path.basename(os.path.dirname(f))

        def million(f):
            return float(open(f).read()) / 1e6

        def stage(f):
            return os.path.basename(f).split('.', 1)[1].replace('.gz', '').replace('.count', '')

        df = pd.DataFrame(dict(filename=list(map(str, input))))
        df['sample'] = df.filename.apply(sample)
        df['million'] = df.filename.apply(million)
        df['stage'] = df.filename.apply(stage)
        df = df.set_index('filename')
        df = df.pivot('sample', columns='stage', values='million')

        # make nicer column names
        convert = {
            'fastq.libsize': 'stage1_raw',
            'cutadapt.fastq.libsize' : 'stage2_trimmed',
            'cutadapt.bam.libsize': 'stage3_aligned',
        }

        df.columns = [convert[i] for i in df.columns]

        df.to_csv(output.tsv, sep='\t')
        y = {
            'id': 'libsizes_table',
            'section_name': 'Library sizes',
            'description': 'Library sizes at various stages of the pipeline',
            'plot_type': 'table',
            'pconfig': {
                'id': 'libsizes_table_table',
                'title': 'Library size table',
                'min': 0
            },
            'data': yaml.load(df.transpose().to_json()),
        }
        with open(output.json, 'w') as fout:
            yaml.dump(y, fout, default_flow_style=False)


rule multiqc:
    """
    Aggregate various QC stats and logs into a single HTML report with MultiQC
    """
    # NOTE: if you add more rules and want MultiQC to pick up the output, then
    # add outputs from those rules to the inputs here.
    input:
        files=(
            utils.flatten(c.targets['fastqc']['pattern']) +
            utils.flatten(c.targets['libsizes_yaml']['pattern']) +
            utils.flatten(c.targets['rrna_percentages_yaml']['pattern']) +
            utils.flatten(c.targets['cutadapt']['pattern']) +
            utils.flatten(c.targets['featurecounts']['pattern']) +
            utils.flatten(c.targets['bam']['pattern']) +
            utils.flatten(c.targets['markduplicates']['pattern']) +
            utils.flatten(c.targets['salmon']['pattern']) +
            utils.flatten(c.targets['rseqc']['pattern']) +
            utils.flatten(c.targets['fastq_screen']['pattern']) +
            utils.flatten(c.targets['dupradar']['pattern']) +
            utils.flatten(c.targets['preseq']['pattern']) +
            utils.flatten(c.targets['collectrnaseqmetrics']['pattern'])
        ),
        config='config/multiqc_config.yaml'
    output: report(c.targets['multiqc']['pattern'], caption=final_rst['multiqc']['pattern'], category='QC')
    log: c.targets['multiqc']['pattern'][0] + '.log'
    run:
        analysis_directory = set([os.path.dirname(i) for i in input])
        outdir = os.path.dirname(c.targets['multiqc']['pattern'][0])
        basename = os.path.basename(c.targets['multiqc']['pattern'][0])
        shell(
            'LC_ALL=en_US.UTF.8 LC_LANG=en_US.UTF-8 '
            'multiqc '
            '--quiet '
            '--outdir {outdir} '
            '--force '
            '--filename {basename} '
            '--config {input.config} '
            '{analysis_directory} '
            '&> {log} '
        )

rule markduplicates:
    """
    Mark or remove PCR duplicates with Picard MarkDuplicates
    """
    input:
        bam=c.patterns['bam']['pattern']
    output:
        bam=c.patterns['markduplicates']['pattern']['bam'],
        metrics=c.patterns['markduplicates']['pattern']['metrics'],
#                       caption=final_rst['markduplicates']['pattern']['metrics'],
#                       category='Metrics')
    log:
        c.patterns['markduplicates']['pattern']['bam'] + '.log'
    params:
        # NOTE: Be careful with the memory here; make sure you have enough
        # and/or it matches the resources you're requesting in the cluster
        # config.
        java_args='-Xmx20g'
        # java_args='-Xmx2g'  # [TEST SETTINGS -1]
    shell:
        'picard '
        '{params.java_args} '
        'MarkDuplicates '
        'INPUT={input.bam} '
        'OUTPUT={output.bam} '
        'METRICS_FILE={output.metrics} '
        '&> {log}'


rule collectrnaseqmetrics:
    """
    Calculate various RNA-seq QC metrics with Picarc CollectRnaSeqMetrics
    """
    input:
        bam=c.patterns['bam']['pattern'],
        refflat=c.refdict[c.organism][config['gtf']['tag']]['refflat']
    output:
        metrics=report(c.patterns['collectrnaseqmetrics']['pattern']['metrics'],
                       caption=final_rst['collectrnaseqmetrics']['pattern']['metrics'],
                       category='Metrics'),
        pdf=report(c.patterns['collectrnaseqmetrics']['pattern']['pdf'],
                       caption=final_rst['collectrnaseqmetrics']['pattern']['pdf'],
                       category='Metrics'),
    params:
        # NOTE: Be careful with the memory here; make sure you have enough
        # and/or it matches the resources you're requesting in the cluster
        # config.
        java_args='-Xmx20g'
        # java_args='-Xmx2g'  # [TEST SETTINGS -1]
    log:
        c.patterns['collectrnaseqmetrics']['pattern']['metrics'] + '.log'
    shell:
        'picard '
        '{params.java_args} '
        'CollectRnaSeqMetrics '

        # NOTE: Adjust strandedness appropriately. From the Picard docs:
        #
        #     STRAND=StrandSpecificity For strand-specific library prep. For
        #     unpaired reads, use FIRST_READ_TRANSCRIPTION_STRAND if the reads
        #     are expected to be on the transcription strand.  Required.
        #     Possible values: {NONE, FIRST_READ_TRANSCRIPTION_STRAND,
        #     SECOND_READ_TRANSCRIPTION_STRAND}
        #
        'STRAND=NONE '

        'CHART_OUTPUT={output.pdf} '
        'REF_FLAT={input.refflat} '
        'INPUT={input.bam} '
        'OUTPUT={output.metrics} '
        '&> {log}'


rule preseq:
    """
    Compute a library complexity curve with preseq
    """
    input:
        bam=c.patterns['bam']['pattern']
    output:
        report(c.patterns['preseq']['pattern'],
                caption=final_rst['preseq']['pattern'],
                category='Metrics'),

    shell:
        'preseq '
        'c_curve '
        '-B {input} '
        '-o {output} '


rule dupRadar:
    """
    Assess the library complexity with dupRadar
    """
    input:
        bam=rules.markduplicates.output.bam,
        annotation=c.refdict[c.organism][config['gtf']['tag']]['gtf'],
    output:
        density_scatter=report(c.patterns['dupradar']['pattern']['density_scatter'],
                               caption=final_rst['dupradar']['pattern']['density_scatter'],
                               category='dupRadar'),
        expression_histogram=report(c.patterns['dupradar']['pattern']['expression_histogram'],
                                caption=final_rst['dupradar']['pattern']['expression_histogram'],
                               category='dupRadar'),
        expression_boxplot=report(c.patterns['dupradar']['pattern']['expression_boxplot'],
                                caption=final_rst['dupradar']['pattern']['expression_boxplot'],
                               category='dupRadar'),
        expression_barplot=report(c.patterns['dupradar']['pattern']['expression_barplot'],
                                caption=final_rst['dupradar']['pattern']['expression_barplot'],
                               category='dupRadar'),
        multimapping_histogram=report(c.patterns['dupradar']['pattern']['multimapping_histogram'],
                                caption=final_rst['dupradar']['pattern']['multimapping_histogram'],
                               category='dupRadar'),
        dataframe=report(c.patterns['dupradar']['pattern']['dataframe'],
                                caption=final_rst['dupradar']['pattern']['dataframe'],
                               category='dupRadar'),
        model=report(c.patterns['dupradar']['pattern']['model'],
                                caption=final_rst['dupradar']['pattern']['model'],
                               category='dupRadar'),
        curve=report(c.patterns['dupradar']['pattern']['curve'],
                                caption=final_rst['dupradar']['pattern']['curve'],
                               category='dupRadar'),

    log: c.patterns['dupradar']['pattern']['dataframe'] + '.log'
    script:
        wrapper_for('dupradar/wrapper.py')


rule salmon:
    """
    Quantify reads coming from transcripts with Salmon
    """
    input:
        fastq=common.fill_r1_r2(c.sampletable, c.patterns['cutadapt']['pattern']),
        index=c.refdict[c.organism][config['salmon']['tag']]['salmon'],
    output:
        report(c.patterns['salmon']['pattern'],
               caption=final_rst['salmon']['pattern'],
               category='quantification')
    params:
        index_dir=os.path.dirname(c.refdict[c.organism][config['salmon']['tag']]['salmon']),
        outdir=os.path.dirname(c.patterns['salmon']['pattern'])
    log:
        c.patterns['salmon']['pattern'] + '.log'
    run:
        paired = len(input.fastq) == 2
        if paired:
            shell(
                # NOTE: adjust Salmon params as needed
                'salmon quant '
                '--index {params.index_dir} '
                '--output {params.outdir} '
                '--threads {threads} '

                # NOTE: --libType=A auto-detects library type. Change if needed.
                '--libType=A '

                # NOTE: Docs suggest using --gcBias and --seqBias is a good idea
                '--gcBias '
                '--seqBias '
                '-1 {input.fastq[0]} '
                '-2 {input.fastq[1]} '
                '&> {log}'
            )
        else:
            shell(
                # NOTE: adjust Salmon params as needed
                'salmon quant '
                '--index {params.index_dir} '
                '--output {params.outdir} '
                '--threads {threads} '

                # NOTE: --libType=A auto-detects library type. Change if needed.
                '--libType=A '

                # NOTE: Docs suggest using --gcBias and --seqBias is a good idea
                '--gcBias '
                '--seqBias '
                '-r {input.fastq} '
                '&> {log}'
            )
        shell('mv {params.outdir}/quant.sf {output}')


rule rseqc_bam_stat:
    """
    Calculate various BAM stats with RSeQC
    """
    input:
        bam=c.patterns['bam']['pattern']
    output:
        txt=report(c.patterns['rseqc']['pattern']['bam_stat'],
                   caption=final_rst['rseqc']['pattern']['bam_stat'],
                   category='QC')
    wrapper: wrapper_for('rseqc/bam_stat')


rule bigwig_neg:
    """
    Create a bigwig for negative-strand reads
    """
    input:
        bam=c.patterns['bam']['pattern'],
        bai=c.patterns['bam']['pattern'] + '.bai',
    output: c.patterns['bigwig']['pattern']['neg']
    threads: 8
    log:
        c.patterns['bigwig']['pattern']['neg'] + '.log'
    shell:
        # NOTE: adjust bamCoverage params as needed
        # Make sure the bigwig_pos rule below reflects the same changes.
        'bamCoverage '
        '--bam {input.bam} '
        '-o {output} '
        '-p {threads} '
        '--minMappingQuality 20 '
        '--ignoreDuplicates '
        '--smoothLength 10 '
        '--filterRNAstrand forward '
        '--normalizeUsing BPM '
        '&> {log}'


rule bigwig_pos:
    """
    Create a bigwig for postive-strand reads.
    """
    input:
        bam=c.patterns['bam']['pattern'],
        bai=c.patterns['bam']['pattern'] + '.bai',
    output: c.patterns['bigwig']['pattern']['pos']
    threads: 8
    log:
        c.patterns['bigwig']['pattern']['pos'] + '.log'
    shell:
        # NOTE: adjust bamCoverage params as needed
        # Make sure the bigwig_neg rule above reflects the same changes.
        'bamCoverage '
        '--bam {input.bam} '
        '-o {output} '
        '-p {threads} '
        '--minMappingQuality 20 '
        '--ignoreDuplicates '
        '--smoothLength 10 '
        '--filterRNAstrand reverse '
        '--normalizeUsing BPM '
        '&> {log}'


rule symlink_bigwigs:
    input:
        pos=c.patterns['bigwig']['pattern']['pos'],
        neg=c.patterns['bigwig']['pattern']['neg'],
    output:
        sense=report(c.patterns['bigwig']['pattern']['sense'],
                     caption=final_rst['bigwig']['pattern']['sense'],
                     category='bigwig'),
        antisense=report(c.patterns['bigwig']['pattern']['antisense'],
                    caption=final_rst['bigwig']['pattern']['antisense'],
                    category='bigwig'),

    run:
        # NOTE:
        #    In our test data, reads mapping to the positive strand correspond
        #    to sense-strand transcripts. If your protocol is reversed (e.g.,
        #    TruSeq kits), you can map negative-strand reads to "sense". The
        #    track hub creation in rnaseq_trackhub.py only cares about the
        #    `sense` and `antisense` versions, so it's cheap to mess around
        #    with the symlinking here.
        #
        # E.g., use this for TruSeq:
        # utils.make_relative_symlink(input.pos, output.antisense)
        # utils.make_relative_symlink(input.neg, output.sense)

        utils.make_relative_symlink(input.pos, output.sense)
        utils.make_relative_symlink(input.neg, output.antisense)


rule rnaseq_rmarkdown:
    """
    Run and render the RMarkdown file that performs differential expression
    """
    input:
        featurecounts=utils.flatten(c.targets['featurecounts']['pattern']),
        salmon=utils.flatten(c.targets['salmon']['pattern']),

        # NOTE: the Rmd will likely need heavy editing depending on the project.
        rmd='downstream/rnaseq.Rmd',
        sampletable=config['sampletable']
    output:
        report('downstream/rnaseq.html',
               caption=final_rst['downstream']['pattern']['rnaseq'])
    shell:
        'Rscript -e '
        '''"rmarkdown::render('{input.rmd}', 'knitrBootstrap::bootstrap_document')"'''


def bigwigs_to_merge(wc):
    chunk = config['merged_bigwigs'][wc.merged_bigwig_label]
    antisense_labels = chunk.get('antisense', [])
    sense_labels = chunk.get('sense', [])
    sense_bigwigs = expand(
        c.patterns['bigwig']['pattern']['sense'],
        sample=sense_labels
    )
    antisense_bigwigs = expand(
        c.patterns['bigwig']['pattern']['antisense'],
        sample=antisense_labels)
    return sense_bigwigs + antisense_bigwigs

if 'merged_bigwigs' in config:
    rule merge_bigwigs:
        """
        Merge together bigWigs as specified in the config ("merged_bigwigs"
        section).
        """
        input:
            bigwigs=bigwigs_to_merge,
            chromsizes=refdict[c.organism][config['aligner']['tag']]['chromsizes'],
        output:
            report(c.patterns['merged_bigwig']['pattern'], caption=(
                 final_rst['merged_bigwig']['pattern']),
                   category='bigwig')
        log:
            c.patterns['merged_bigwig']['pattern'] + '.log'
        script:
            wrapper_for('average-bigwigs/wrapper.py')

# vim: ft=python
